---
phase: 10-factory-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/schemas/common.ts
  - src/api/schemas/factories.ts
  - src/repositories/FactoryRepository.ts
autonomous: true

must_haves:
  truths:
    - "Pagination query parameters are validated (limit 1-100, offset >= 0, defaults 20/0)"
    - "Factory create/update request bodies are validated with Zod schemas"
    - "Factory response schema excludes deleted_at and converts dates to ISO strings"
    - "FactoryRepository supports paginated queries with limit/offset"
    - "FactoryRepository provides count of non-deleted factories"
  artifacts:
    - path: "src/api/schemas/common.ts"
      provides: "Reusable pagination query schema and pagination response schema"
      exports: ["paginationQuerySchema", "paginationResponseSchema"]
    - path: "src/api/schemas/factories.ts"
      provides: "Create, update, and response Zod schemas for factory endpoints"
      exports: ["createFactorySchema", "updateFactorySchema", "factoryResponseSchema", "factoryListResponseSchema"]
    - path: "src/repositories/FactoryRepository.ts"
      provides: "Paginated findAll and count methods"
      contains: "findAll.*limit.*offset"
  key_links:
    - from: "src/api/schemas/factories.ts"
      to: "src/api/schemas/common.ts"
      via: "imports paginationResponseSchema"
      pattern: "import.*paginationResponseSchema.*common"
    - from: "src/repositories/FactoryRepository.ts"
      to: "kysely"
      via: "limit/offset query methods"
      pattern: "\\.limit\\(.*\\.offset\\("
---

<objective>
Create Zod validation schemas for factory API requests/responses and add pagination support to FactoryRepository.

Purpose: Establish the validation and data access foundation that factory CRUD routes will consume. Separating schemas and repository changes from route implementation keeps each plan focused and under context budget.

Output: Reusable schema files for common pagination and factory-specific validation, plus an enhanced FactoryRepository that supports paginated queries with total count.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-factory-api/10-RESEARCH.md

@src/repositories/FactoryRepository.ts
@src/repositories/types.ts
@src/api/routes/health.ts
@src/api/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schemas for factory API</name>
  <files>src/api/schemas/common.ts, src/api/schemas/factories.ts</files>
  <action>
Create `src/api/schemas/common.ts` with reusable pagination schemas:
- `paginationQuerySchema`: z.object with `limit` (z.coerce.number().min(1).max(100).default(20)) and `offset` (z.coerce.number().min(0).default(0)). Use z.coerce because query parameters arrive as strings.
- `paginationResponseSchema`: z.object with `total` (z.number()), `limit` (z.number()), `offset` (z.number()), `hasNext` (z.boolean()), `hasPrev` (z.boolean()).

Create `src/api/schemas/factories.ts` with factory-specific schemas:
- `createFactorySchema`: z.object with `organization_id` (z.string().uuid()), `name` (z.string().min(1).max(255)), `location` (z.string().max(500).nullable().optional()), `timezone` (z.string().default('UTC')), `metadata` (z.record(z.string(), z.unknown()).default({})).
- `updateFactorySchema`: z.object with `name` (z.string().min(1).max(255).optional()), `location` (z.string().max(500).nullable().optional()), `timezone` (z.string().optional()), `metadata` (z.record(z.string(), z.unknown()).optional()). Note: organization_id is NOT updatable.
- `factoryResponseSchema`: z.object with `id` (z.string().uuid()), `organization_id` (z.string().uuid()), `name` (z.string()), `location` (z.string().nullable()), `timezone` (z.string()), `metadata` (z.record(z.string(), z.unknown())), `created_at` (z.string().datetime()), `updated_at` (z.string().datetime()). Exclude deleted_at — API consumers should not see soft delete internals.
- `factoryListResponseSchema`: z.object with `data` (z.array(factoryResponseSchema)) and `pagination` (paginationResponseSchema imported from common.ts).

Follow the same import/export style as existing schemas in `src/repositories/types.ts`. Import z from 'zod'.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors in the new schema files. Verify the files exist and export the expected symbols.
  </verify>
  <done>
Two schema files exist. Common pagination schema is reusable for future Gateway API. Factory schemas validate create body (organization_id required), update body (all optional), and response (dates as ISO strings, no deleted_at). TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pagination support to FactoryRepository</name>
  <files>src/repositories/FactoryRepository.ts</files>
  <action>
Modify `FactoryRepository.findAll()` to accept an optional options parameter for pagination:

```typescript
async findAll(options?: { limit?: number; offset?: number }): Promise<Factory[]> {
  let query = db
    .selectFrom('factories')
    .selectAll()
    .where('deleted_at', 'is', null)
    .orderBy('name', 'asc');

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  if (options?.offset) {
    query = query.offset(options.offset);
  }

  return await query.execute();
}
```

Add a new `count()` method for pagination metadata:

```typescript
async count(): Promise<number> {
  const result = await db
    .selectFrom('factories')
    .select(db.fn.countAll().as('count'))
    .where('deleted_at', 'is', null)
    .executeTakeFirstOrThrow();

  return Number(result.count);
}
```

The existing findAll() call signature is backward compatible — callers without options get the same behavior as before (all non-deleted factories, ordered by name).
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors. Verify the findAll method signature accepts optional pagination parameters. Verify the count method exists and returns a number.
  </verify>
  <done>
FactoryRepository.findAll() accepts optional { limit, offset } for pagination while remaining backward-compatible with existing callers. count() method returns total non-deleted factories for pagination metadata. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/api/schemas/common.ts` exports paginationQuerySchema and paginationResponseSchema
3. `src/api/schemas/factories.ts` exports createFactorySchema, updateFactorySchema, factoryResponseSchema, factoryListResponseSchema
4. `src/repositories/FactoryRepository.ts` has findAll with optional pagination and count() method
5. No existing functionality broken (findAll without args still works)
</verification>

<success_criteria>
- Schema files exist and compile
- FactoryRepository supports paginated queries
- All existing code continues to work (backward compatible)
- Foundation ready for Plan 02 to build routes on top
</success_criteria>

<output>
After completion, create `.planning/phases/10-factory-api/10-01-SUMMARY.md`
</output>
