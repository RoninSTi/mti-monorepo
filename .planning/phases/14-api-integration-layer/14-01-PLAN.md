---
phase: 14-api-integration-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/hooks/useFactories.ts
  - frontend/src/lib/query-client.ts
autonomous: true

must_haves:
  truths:
    - "useFactories() returns factory list with loading/error/data states"
    - "useFactory(id) returns single factory by ID"
    - "useCreateFactory() mutation creates factory and invalidates list cache"
    - "useUpdateFactory() mutation updates factory with optimistic update and rollback"
    - "useDeleteFactory() mutation soft-deletes factory and invalidates list cache"
    - "Background query errors are logged via global QueryCache onError handler"
  artifacts:
    - path: "frontend/src/hooks/useFactories.ts"
      provides: "Factory CRUD hooks with query key factory"
      exports: ["factoryKeys", "useFactories", "useFactory", "useCreateFactory", "useUpdateFactory", "useDeleteFactory"]
    - path: "frontend/src/lib/query-client.ts"
      provides: "Enhanced QueryClient with global error handling"
      contains: "QueryCache"
  key_links:
    - from: "frontend/src/hooks/useFactories.ts"
      to: "frontend/src/lib/api.ts"
      via: "api.get/post/put/delete calls"
      pattern: "api\\.(get|post|put|delete)"
    - from: "frontend/src/hooks/useFactories.ts"
      to: "frontend/src/types/api.ts"
      via: "TypeScript type imports"
      pattern: "import type.*from '@/types/api'"
    - from: "frontend/src/lib/query-client.ts"
      to: "frontend/src/types/api.ts"
      via: "ApiError type import"
      pattern: "import type.*ApiError"
---

<objective>
Create React Query custom hooks for factory CRUD operations and enhance global error handling.

Purpose: Provide a type-safe data layer that factory UI pages (Phase 15) will consume. Factory hooks encapsulate query keys, fetcher functions, cache invalidation, and optimistic updates so UI components focus purely on presentation.

Output: `hooks/useFactories.ts` with 5 exported hooks + query key factory, enhanced `query-client.ts` with global error handler.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@frontend/src/lib/api.ts
@frontend/src/lib/query-client.ts
@frontend/src/types/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create factory CRUD hooks with query key factory</name>
  <files>frontend/src/hooks/useFactories.ts</files>
  <action>
Create `frontend/src/hooks/useFactories.ts` with the following exports:

**Query key factory** (`factoryKeys`):
- `all`: `['factories'] as const` - root key for all factory queries
- `lists()`: `[...all, 'list']` - all list queries
- `list(filters)`: `[...lists(), filters]` - specific list with pagination params `{ limit?: number; offset?: number }`
- `details()`: `[...all, 'detail']` - all detail queries
- `detail(id)`: `[...details(), id]` - specific factory by UUID

**Hooks:**

1. `useFactories(params?: { limit?: number; offset?: number })` - Returns `useQuery` result typed as `PaginatedResponse<Factory>`. Build query string from params using URLSearchParams. Query key: `factoryKeys.list(params || {})`.

2. `useFactory(id: string)` - Returns `useQuery` result typed as `Factory`. Use `enabled: !!id` to prevent fetching with empty string. Query key: `factoryKeys.detail(id)`.

3. `useCreateFactory()` - Returns `useMutation` with `mutationFn` accepting `CreateFactoryInput`, posting to `/factories`, typed response `Factory`. On success: invalidate `factoryKeys.lists()`.

4. `useUpdateFactory()` - Returns `useMutation` with `mutationFn` accepting `{ id: string; data: UpdateFactoryInput }`, PUT to `/factories/${id}`. Implements full optimistic update pattern:
   - `onMutate`: Cancel queries for detail(id), snapshot previous, optimistically set new data with spread `{ ...previous, ...data, updated_at: new Date().toISOString() }`
   - `onError`: Rollback to snapshot
   - `onSettled`: Invalidate both `detail(id)` and `lists()` to sync with server

5. `useDeleteFactory()` - Returns `useMutation` with `mutationFn` accepting `id: string`, DELETE to `/factories/${id}`. On success: invalidate `factoryKeys.lists()`.

Import `useQuery`, `useMutation`, `useQueryClient` from `@tanstack/react-query`. Import `api` from `@/lib/api`. Import types from `@/types/api`.

Follow the exact patterns from 14-RESEARCH.md code examples. Do NOT add toast notifications (deferred to Phase 15).
  </action>
  <verify>
Run `cd frontend && npx tsc --noEmit` - zero TypeScript errors. Verify the file exports all 6 items: `factoryKeys`, `useFactories`, `useFactory`, `useCreateFactory`, `useUpdateFactory`, `useDeleteFactory`.
  </verify>
  <done>
All 5 factory hooks and the query key factory are exported, TypeScript compiles cleanly, hooks use correct API endpoints and types, optimistic update implemented on useUpdateFactory with onMutate/onError/onSettled pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance QueryClient with global error handling</name>
  <files>frontend/src/lib/query-client.ts</files>
  <action>
Update `frontend/src/lib/query-client.ts` to add a global error handler for background query failures using QueryCache.

Changes:
1. Add import: `QueryCache` from `@tanstack/react-query`
2. Add import: `type ApiError` from `@/types/api`
3. Create `new QueryCache({ onError: ... })` that:
   - Casts error to `ApiError`
   - Extracts message with fallback: `apiError?.message || 'An unexpected error occurred'`
   - Logs via `console.error('Background query error:', message)` (no toast library yet - Phase 15 will add toast)
4. Pass the QueryCache instance to QueryClient constructor: `queryCache: queryCache`
5. Keep existing defaultOptions exactly as-is (staleTime 5min, retry 1, refetchOnWindowFocus false)

This handles background refetch errors gracefully. Component-level error handling (isError checks) will be added in Phase 15 UI pages.
  </action>
  <verify>
Run `cd frontend && npx tsc --noEmit` - zero TypeScript errors. Verify `query-client.ts` imports QueryCache and ApiError, creates QueryCache with onError handler.
  </verify>
  <done>
QueryClient enhanced with global QueryCache error handler that extracts user-friendly messages from ApiError responses, existing configuration preserved.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` passes with zero errors
2. `frontend/src/hooks/useFactories.ts` exists and exports factoryKeys, useFactories, useFactory, useCreateFactory, useUpdateFactory, useDeleteFactory
3. `frontend/src/lib/query-client.ts` imports QueryCache and has onError handler
4. All hooks use correct API endpoints: `/factories`, `/factories/${id}`
5. Optimistic update on useUpdateFactory has onMutate, onError, and onSettled callbacks
</verification>

<success_criteria>
- Factory CRUD hooks compile and export all 6 items
- Query key factory uses hierarchical array keys for precise invalidation
- useUpdateFactory implements snapshot-and-rollback optimistic update
- Global error handler extracts ApiError messages with fallback
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-api-integration-layer/14-01-SUMMARY.md`
</output>
