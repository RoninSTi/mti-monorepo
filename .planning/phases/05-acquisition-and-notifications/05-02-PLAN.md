---
phase: 05-acquisition-and-notifications
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/gateway/notification-handler.ts
  - src/acquisition/acquisition-manager.ts
autonomous: true

must_haves:
  truths:
    - "NotificationHandler emits events that can be awaited with events.once()"
    - "AcquisitionManager subscribes to notifications before triggering readings"
    - "AcquisitionManager registers notification listeners BEFORE sending TAKE_DYN_READING (race condition prevention)"
    - "NOT_DYN_READING_STARTED Success field is checked and false causes error"
    - "Acquisition times out after configurable duration (default 60s)"
    - "Temperature notification is awaited separately without blocking main flow"
    - "POST_UNSUB_CHANGES is sent during cleanup"
  artifacts:
    - path: "src/gateway/notification-handler.ts"
      provides: "EventEmitter-based notification handler compatible with events.once()"
      exports: ["NotificationHandler"]
      contains: "extends EventEmitter"
    - path: "src/acquisition/acquisition-manager.ts"
      provides: "Orchestrates subscribe -> trigger reading -> await notifications -> parse -> display flow"
      exports: ["AcquisitionManager"]
  key_links:
    - from: "src/acquisition/acquisition-manager.ts"
      to: "src/gateway/notification-handler.ts"
      via: "events.once(notificationHandler, type) to await notifications"
      pattern: "once.*notificationHandler"
    - from: "src/acquisition/acquisition-manager.ts"
      to: "src/gateway/command-client.ts"
      via: "commandClient.sendCommand() for POST_SUB_CHANGES, TAKE_DYN_READING, POST_UNSUB_CHANGES"
      pattern: "sendCommand"
    - from: "src/acquisition/acquisition-manager.ts"
      to: "src/acquisition/waveform-parser.ts"
      via: "parseWaveform() to decode X/Y/Z strings"
      pattern: "parseWaveform"
    - from: "src/acquisition/acquisition-manager.ts"
      to: "src/output/waveform-display.ts"
      via: "displayReadingResults() to show output"
      pattern: "displayReadingResults"
---

<objective>
Enhance NotificationHandler to support EventEmitter pattern and create the AcquisitionManager that orchestrates the full reading flow.

Purpose: The AcquisitionManager is the core of Phase 5 - it coordinates subscribe, trigger, await notifications, parse waveforms, and display results. The NotificationHandler must extend EventEmitter so we can use native `events.once()` for Promise-based notification awaiting (per research recommendation).

Output: Enhanced NotificationHandler and complete AcquisitionManager ready for main.ts wiring.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-acquisition-and-notifications/05-RESEARCH.md
@src/gateway/notification-handler.ts
@src/gateway/command-client.ts
@src/gateway/message-router.ts
@src/types/messages.ts
@src/config.ts
@src/acquisition/waveform-parser.ts
@src/output/waveform-display.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance NotificationHandler to extend EventEmitter</name>
  <files>src/gateway/notification-handler.ts</files>
  <action>
Modify NotificationHandler to extend EventEmitter while preserving backward compatibility with the existing `.on()` callback pattern used by MessageRouter.

Changes:
1. Import EventEmitter: `import { EventEmitter } from 'node:events';`
2. Change class declaration: `export class NotificationHandler extends EventEmitter`
3. Add `constructor() { super(); }` to call EventEmitter constructor
4. Keep the existing `handlers` Map for backward-compatible `.on(type, callback)` registration
5. Rename the existing `.on()` method to `.register()` to avoid conflict with EventEmitter's `.on()`:
   ```typescript
   register(type: string, callback: (data: unknown) => void): void {
     this.handlers.set(type, callback);
     logger.debug(`Registered notification handler for: ${type}`);
   }
   ```
   NOTE: Check if any code calls `.on()` on NotificationHandler. If so, update those call sites. Current codebase has NO `.on()` calls in main.ts or elsewhere (Phase 5 was supposed to add them). The only existing `.on()` call is the method definition itself. So renaming is safe.

6. Update `handle(message)` to BOTH call registered callbacks AND emit events:
   ```typescript
   handle(message: NotificationMessage): void {
     logger.debug(`Notification received: ${message.Type}`);

     // Call registered callback handler (backward compat)
     const handler = this.handlers.get(message.Type);
     if (handler) {
       handler(message.Data);
     }

     // Emit event for events.once() consumers (Phase 5 acquisition)
     this.emit(message.Type, message.Data);
   }
   ```

This dual dispatch means:
- MessageRouter calls `notificationHandler.handle(message)` (unchanged)
- AcquisitionManager uses `events.once(notificationHandler, 'NOT_DYN_READING')` (new)
- Both work simultaneously

IMPORTANT: Do NOT remove the `handlers` Map or the `register()` method. Future code may still use callback registration. The EventEmitter `.emit()` is additive.
  </action>
  <verify>
`npx tsc --noEmit` compiles without errors. NotificationHandler extends EventEmitter. `handle()` method calls both `this.emit()` and registered callback. No existing code breaks (grep for `.on(` usage on NotificationHandler instances in main.ts and message-router.ts).
  </verify>
  <done>
NotificationHandler extends EventEmitter, emits typed events on notification receipt, maintains backward-compatible callback registration via `.register()` method. MessageRouter integration unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AcquisitionManager</name>
  <files>src/acquisition/acquisition-manager.ts</files>
  <action>
Create `src/acquisition/acquisition-manager.ts` implementing the full acquisition flow from research Pattern 4.

Imports:
- `{ once } from 'node:events'`
- `{ CommandClient } from '../gateway/command-client'`
- `{ NotificationHandler } from '../gateway/notification-handler'`
- `{ SensorMetadata } from '../types/messages'`
- `{ parseWaveform } from './waveform-parser'`
- `{ displayReadingResults } from '../output/waveform-display'`
- `{ logger } from '../utils/logger'`

Export class `AcquisitionManager`:

**Constructor:**
```typescript
constructor(
  private commandClient: CommandClient,
  private notificationHandler: NotificationHandler,
  private acquisitionTimeoutMs: number = 60000
)
```
Private field: `private isSubscribed = false;`

**Method: `async subscribe(): Promise<void>`** (SUB-01)
- If already subscribed, return early
- Send POST_SUB_CHANGES: `await this.commandClient.sendCommand({ Type: 'POST_SUB_CHANGES', From: 'UI', To: 'SERV', Data: {} })`
- Set `this.isSubscribed = true`
- Log: `logger.info('Subscribed to gateway notifications')`

**Method: `async acquireReading(sensor: SensorMetadata): Promise<void>`** (ACQ-01 through ACQ-08, OUT-01 through OUT-06)
- Guard: if not subscribed, throw Error('Must subscribe before acquiring reading')
- CRITICAL: Register notification listeners BEFORE triggering command (Pitfall 1 from research):
  ```typescript
  const startedPromise = once(this.notificationHandler, 'NOT_DYN_READING_STARTED');
  const readingPromise = once(this.notificationHandler, 'NOT_DYN_READING');
  const tempPromise = once(this.notificationHandler, 'NOT_DYN_TEMP');
  ```
- Send TAKE_DYN_READING (ACQ-01):
  ```typescript
  await this.commandClient.sendCommand({
    Type: 'TAKE_DYN_READING',
    From: 'UI',
    To: 'SERV',
    Data: { Serial: sensor.Serial },
  });
  logger.info(`Triggered reading for sensor Serial=${sensor.Serial}`);
  ```

- Create timeout helper (local to this method):
  ```typescript
  const timeoutPromise = (ms: number, msg: string): Promise<never> =>
    new Promise((_, reject) => setTimeout(() => reject(new Error(msg)), ms));
  ```

- Wait for NOT_DYN_READING_STARTED (ACQ-02, ACQ-03) with 30s timeout:
  ```typescript
  const [startedData] = await Promise.race([
    startedPromise,
    timeoutPromise(30000, 'Timeout waiting for NOT_DYN_READING_STARTED (30s)')
  ]) as [{ Serial: number; Success: boolean }];

  if (!startedData.Success) {
    throw new Error(`Reading failed to start for sensor Serial=${startedData.Serial}`);
  }
  logger.info('Reading started successfully');
  ```

- Wait for NOT_DYN_READING (ACQ-04, ACQ-05) with acquisition timeout:
  ```typescript
  const [readingData] = await Promise.race([
    readingPromise,
    timeoutPromise(this.acquisitionTimeoutMs, `Timeout waiting for NOT_DYN_READING (${this.acquisitionTimeoutMs}ms)`)
  ]) as [{ ID: number; Serial: string; Time: string; X: string; Y: string; Z: string }];

  logger.info(`Reading received: ID=${readingData.ID}, Serial=${readingData.Serial}, Time=${readingData.Time}`);
  ```

- Parse waveform (ACQ-06):
  ```typescript
  const waveforms = parseWaveform(readingData.X, readingData.Y, readingData.Z, sensor.Samples);
  ```

- Handle temperature (ACQ-07) - non-blocking with 10s timeout:
  ```typescript
  let temperature: number | undefined;
  try {
    const [tempData] = await Promise.race([
      tempPromise,
      timeoutPromise(10000, 'Temperature notification timeout')
    ]) as [{ Serial: string; Temp: number }];
    temperature = tempData.Temp;
    logger.info(`Temperature received: ${temperature}C`);
  } catch {
    logger.debug('Temperature notification not received (optional, continuing)');
  }
  ```

- Display results (OUT-01 through OUT-06):
  ```typescript
  displayReadingResults(
    sensor,
    { ID: readingData.ID, Serial: readingData.Serial, Time: readingData.Time },
    waveforms,
    temperature
  );
  ```

**Method: `async unsubscribe(): Promise<void>`** (SUB-04)
- If not subscribed, return early
- Send POST_UNSUB_CHANGES: `await this.commandClient.sendCommand({ Type: 'POST_UNSUB_CHANGES', From: 'UI', To: 'SERV', Data: {} })`
- Set `this.isSubscribed = false`
- Log: `logger.info('Unsubscribed from gateway notifications')`
- Wrap in try/catch - log error but don't throw (shutdown path should not fail)

IMPORTANT NOTES:
- Register listeners BEFORE sending TAKE_DYN_READING to prevent race condition
- Temperature is non-blocking: caught and logged, never throws
- Type assertions on once() return values match the Zod schemas from messages.ts
- The `as [type]` assertions are needed because events.once() returns `any[]`
  </action>
  <verify>
`npx tsc --noEmit` compiles without errors. File exists at src/acquisition/acquisition-manager.ts. Exports AcquisitionManager class with subscribe(), acquireReading(), and unsubscribe() methods.
  </verify>
  <done>
AcquisitionManager orchestrates full acquisition flow: subscribe to notifications, register listeners before triggering, send TAKE_DYN_READING, await NOT_DYN_READING_STARTED (check Success), await NOT_DYN_READING with 60s timeout, parse waveforms, optionally receive temperature, display all results, and unsubscribe on cleanup.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. NotificationHandler extends EventEmitter and emits events in handle()
3. AcquisitionManager registers listeners BEFORE sending TAKE_DYN_READING
4. NOT_DYN_READING_STARTED Success field is checked
5. Acquisition timeout uses configurable value (default 60s)
6. Temperature notification is non-blocking
7. POST_UNSUB_CHANGES sent in unsubscribe()
</verification>

<success_criteria>
- NotificationHandler extends EventEmitter, dual-dispatches to callbacks and events
- AcquisitionManager implements subscribe -> trigger -> await -> parse -> display -> unsubscribe
- Race condition prevented (listeners before command)
- Timeouts correct: 30s for started, 60s for reading, 10s for temperature
- All requirements SUB-01 through SUB-04, ACQ-01 through ACQ-08 covered
</success_criteria>

<output>
After completion, create `.planning/phases/05-acquisition-and-notifications/05-02-SUMMARY.md`
</output>
