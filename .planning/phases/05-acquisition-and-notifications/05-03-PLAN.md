---
phase: 05-acquisition-and-notifications
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "Application subscribes to notifications after authentication"
    - "Application triggers vibration reading and displays waveform data"
    - "Application unsubscribes before shutdown (both normal and error paths)"
    - "Application exits cleanly after acquisition completes"
    - "Acquisition errors are logged without crashing"
  artifacts:
    - path: "src/main.ts"
      provides: "Complete application flow: connect -> authenticate -> discover -> subscribe -> acquire -> display -> unsubscribe -> exit"
      contains: "AcquisitionManager"
  key_links:
    - from: "src/main.ts"
      to: "src/acquisition/acquisition-manager.ts"
      via: "AcquisitionManager instantiation and subscribe/acquireReading/unsubscribe calls"
      pattern: "AcquisitionManager"
    - from: "src/main.ts"
      to: "src/gateway/notification-handler.ts"
      via: "notificationHandler passed to AcquisitionManager constructor"
      pattern: "notificationHandler"
---

<objective>
Wire the AcquisitionManager into main.ts to complete the full application flow from connection through data display and clean shutdown.

Purpose: This is the final integration plan for Phase 5. The existing `onConnectionOpen()` flow in main.ts currently stops after sensor discovery with a "Phase 5 will add..." comment. This plan replaces that comment with the actual acquisition flow and ensures clean shutdown includes unsubscription.

Output: Updated main.ts with complete end-to-end flow.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-acquisition-and-notifications/05-RESEARCH.md
@.planning/phases/05-acquisition-and-notifications/05-01-SUMMARY.md
@.planning/phases/05-acquisition-and-notifications/05-02-SUMMARY.md
@src/main.ts
@src/acquisition/acquisition-manager.ts
@src/gateway/notification-handler.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire AcquisitionManager into main.ts application flow</name>
  <files>src/main.ts</files>
  <action>
Update main.ts to integrate AcquisitionManager into the existing connection flow.

**1. Add import:**
```typescript
import { AcquisitionManager } from './acquisition/acquisition-manager';
```

**2. Create AcquisitionManager after message infrastructure (after the `logger.info('Message infrastructure initialized...')` line):**
```typescript
const acquisitionManager = new AcquisitionManager(
  commandClient,
  notificationHandler,
  config.ACQUISITION_TIMEOUT
);
```

**3. Update shutdown() function to include unsubscribe:**
Before `commandClient.cleanup()`, add:
```typescript
// Unsubscribe from notifications (best-effort, don't block shutdown)
acquisitionManager.unsubscribe().catch((err) => {
  logger.debug(`Unsubscribe during shutdown failed: ${err}`);
});
```

**4. Update onConnectionOpen() to add acquisition after discovery:**

Replace the two lines:
```typescript
logger.info(`Ready for data acquisition with sensor Serial=${sensor.Serial}`);
logger.info('Phase 4 complete: authenticated and sensor discovered');
// Phase 5 will add: subscribe to notifications, trigger reading, display data
```

With the full acquisition flow:
```typescript
// SUB-01: Subscribe to gateway notifications
await acquisitionManager.subscribe();

// ACQ-01 through ACQ-08, OUT-01 through OUT-06: Trigger reading and display results
await acquisitionManager.acquireReading(sensor);

// Complete - unsubscribe and exit
await acquisitionManager.unsubscribe();

logger.info('Acquisition complete - shutting down');
commandClient.cleanup();
connection.close(1000, 'Acquisition complete');
setTimeout(() => process.exit(0), 1000);
```

**5. Keep existing error handling intact.** The try/catch in onConnectionOpen() already handles:
- No sensors (exit 0)
- Auth failure (exit 1)

Add acquisition errors to the catch block. The existing catch handles `error instanceof Error ? error.message : String(error)` which already covers acquisition timeouts and parse failures. But update the catch to also call unsubscribe on acquisition error:

In the generic error path (the `else` branch that does `logger.error`), add unsubscribe before cleanup:
```typescript
// Try to unsubscribe if we got far enough
acquisitionManager.unsubscribe().catch(() => {});

logger.error(`Startup failed: ${message}`);
commandClient.cleanup();
connection.close(1000, 'Startup failed');
setTimeout(() => process.exit(1), 1000);
```

**Complete updated onConnectionOpen:**
```typescript
async function onConnectionOpen(): Promise<void> {
  try {
    // AUTH-01, AUTH-02: Send POST_LOGIN with credentials
    await authenticate(commandClient, config);

    // AUTH-05: Transition to AUTHENTICATED state
    connection.markAuthenticated();

    // DISC-01 through DISC-04: Discover and select sensor
    const sensor = await discoverSensor(commandClient, config.SENSOR_SERIAL);

    // SUB-01: Subscribe to gateway notifications
    await acquisitionManager.subscribe();

    // ACQ-01 through ACQ-08, OUT-01 through OUT-06
    await acquisitionManager.acquireReading(sensor);

    // SUB-04: Unsubscribe and exit cleanly
    await acquisitionManager.unsubscribe();

    logger.info('Acquisition complete - shutting down');
    commandClient.cleanup();
    connection.close(1000, 'Acquisition complete');
    setTimeout(() => process.exit(0), 1000);

  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);

    // DISC-05: No sensors connected
    if (message.includes('No sensors currently connected')) {
      logger.warn('No sensors available - exiting gracefully');
      commandClient.cleanup();
      connection.close(1000, 'No sensors available');
      setTimeout(() => process.exit(0), 1000);
      return;
    }

    // Auth failure, acquisition failure, or other error
    acquisitionManager.unsubscribe().catch(() => {});
    logger.error(`Failed: ${message}`);
    commandClient.cleanup();
    connection.close(1000, 'Operation failed');
    setTimeout(() => process.exit(1), 1000);
  }
}
```

IMPORTANT: The application is a spike - it connects, authenticates, discovers a sensor, takes one reading, displays the data, and exits. It does NOT run indefinitely. This is intentional per the Milestone 0 scope.
  </action>
  <verify>
`npx tsc --noEmit` compiles without errors. main.ts imports AcquisitionManager. onConnectionOpen() calls subscribe -> acquireReading -> unsubscribe. Shutdown path includes unsubscribe. Application exits with code 0 on success, code 1 on failure.
  </verify>
  <done>
main.ts orchestrates complete flow: connect -> authenticate -> discover sensor -> subscribe to notifications -> trigger reading -> await and parse waveform data -> display results -> unsubscribe -> exit. Error paths include unsubscribe cleanup. Application exits cleanly after single acquisition.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify full build and export integrity</name>
  <files>src/main.ts</files>
  <action>
Run full TypeScript build to verify all Phase 5 modules integrate correctly:

1. Run `npx tsc --noEmit` and verify zero errors
2. Verify import chain is complete:
   - main.ts -> acquisition-manager.ts -> waveform-parser.ts
   - main.ts -> acquisition-manager.ts -> waveform-display.ts (via acquisition-manager)
   - main.ts -> notification-handler.ts (EventEmitter-based)
3. Verify no circular dependencies: acquisition/ modules import from gateway/ and types/, not vice versa
4. If any TypeScript errors, fix them (likely type mismatches between events.once() return and expected types)

If the build reveals issues with the `events.once()` return type (it returns `Promise<any[]>`), ensure the type assertions in acquisition-manager.ts use `as [TypeHere]` pattern or add explicit destructuring.

Also verify that the `once` import from `node:events` is correctly typed by checking tsconfig.json includes `"types": ["node"]` or similar node type inclusion.
  </action>
  <verify>
`npx tsc --noEmit` returns exit code 0 with no output. `npx tsc --noEmit 2>&1 | wc -l` returns 0 (or only whitespace).
  </verify>
  <done>
Full project builds without TypeScript errors. All Phase 5 modules correctly integrate: types flow from Zod schemas through parser, into display, orchestrated by AcquisitionManager, wired in main.ts.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. main.ts imports and instantiates AcquisitionManager
3. onConnectionOpen() calls subscribe -> acquireReading -> unsubscribe
4. Shutdown handler calls unsubscribe (best-effort)
5. Error paths include unsubscribe cleanup
6. Application exits 0 on success, 1 on failure
7. No circular dependencies between modules
</verification>

<success_criteria>
- Complete application flow works: connect -> auth -> discover -> subscribe -> acquire -> display -> unsubscribe -> exit
- All 18 requirements (SUB-01 through SUB-04, ACQ-01 through ACQ-08, OUT-01 through OUT-06) are covered across the three plans
- TypeScript build passes with zero errors
- Clean shutdown includes unsubscription in all paths
</success_criteria>

<output>
After completion, create `.planning/phases/05-acquisition-and-notifications/05-03-SUMMARY.md`
</output>
