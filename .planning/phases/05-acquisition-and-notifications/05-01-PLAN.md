---
phase: 05-acquisition-and-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/acquisition/waveform-parser.ts
  - src/output/waveform-display.ts
autonomous: true

must_haves:
  truths:
    - "Waveform strings can be parsed into numeric arrays using progressive strategy (CSV, JSON, Base64)"
    - "Waveform statistics (min, max, mean, sample count) are computed correctly"
    - "Console output displays sensor metadata, reading metadata, first 10 samples, and axis statistics"
    - "Temperature value is displayed when present"
  artifacts:
    - path: "src/acquisition/waveform-parser.ts"
      provides: "Progressive waveform parser with CSV/JSON/Base64 strategies and validation"
      exports: ["parseWaveform", "WaveformData"]
    - path: "src/output/waveform-display.ts"
      provides: "Console output formatting for sensor metadata, reading data, waveform statistics"
      exports: ["displayReadingResults"]
  key_links:
    - from: "src/acquisition/waveform-parser.ts"
      to: "src/output/waveform-display.ts"
      via: "WaveformData type shared between parser output and display input"
      pattern: "WaveformData"
---

<objective>
Create the waveform parsing and console display utilities for vibration reading data.

Purpose: These are pure utility functions with no dependencies on gateway infrastructure. The waveform parser handles the critical unknown (X/Y/Z encoding format) with a progressive fallback strategy. The display module formats all output requirements (OUT-01 through OUT-06).

Output: Two new files providing parse and display capabilities that the AcquisitionManager (Plan 02) will consume.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-acquisition-and-notifications/05-RESEARCH.md
@src/types/messages.ts
@src/utils/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create progressive waveform parser</name>
  <files>src/acquisition/waveform-parser.ts</files>
  <action>
Create `src/acquisition/` directory and `waveform-parser.ts` with:

1. Export `WaveformData` interface: `{ x: number[]; y: number[]; z: number[] }`

2. Export `parseWaveform(xStr: string, yStr: string, zStr: string, expectedSamples?: number): WaveformData`
   - Implements progressive parsing strategy from research: try CSV first, then JSON array, then Base64 (16-bit signed LE)
   - CSV strategy: `str.split(',').map(v => parseFloat(v.trim()))` - filter out NaN values
   - JSON strategy: `JSON.parse(str)` then validate is array of numbers
   - Base64 strategy: `Buffer.from(str, 'base64')` then read as Int16LE pairs, divide by 1000 for milligravity conversion
   - For each strategy: parse all three axes, then validate:
     a. No NaN or Infinity values: `values.every(v => Number.isFinite(v))`
     b. If expectedSamples provided, check `parsed.length === expectedSamples`
     c. Values in reasonable range: `Math.abs(v) <= 200` (generous range - actual range discovered during testing)
   - Log successful strategy at info level: `logger.info(\`Waveform parsed using ${name} format (${x.length} samples)\`)`
   - Log failed strategies at debug level
   - If all strategies fail, throw Error with message listing all attempted strategies

3. Export `calculateAxisStats(samples: number[]): { min: number; max: number; mean: number; count: number }`
   - Use `Math.min(...samples)` for min (but use reduce for large arrays to avoid stack overflow: `samples.reduce((a, b) => Math.min(a, b), Infinity)`)
   - Same reduce pattern for max
   - Mean: `samples.reduce((a, b) => a + b, 0) / samples.length`
   - Return count as `samples.length`

Import logger from `../utils/logger`.

CRITICAL: The encoding format is UNKNOWN (ACQ-06). The progressive parser is the primary discovery mechanism. Log extensively so we learn the format during Phase 6 testing.
  </action>
  <verify>
`npx tsc --noEmit` compiles without errors. File exists at src/acquisition/waveform-parser.ts. Exports WaveformData, parseWaveform, and calculateAxisStats.
  </verify>
  <done>
Progressive waveform parser handles CSV, JSON, and Base64 formats with validation. Statistics calculator computes min/max/mean/count per axis. All functions exported and typed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create waveform display module</name>
  <files>src/output/waveform-display.ts</files>
  <action>
Create `src/output/` directory and `waveform-display.ts` with:

1. Import types: `SensorMetadata` from `../types/messages`, `WaveformData` and `calculateAxisStats` from `../acquisition/waveform-parser`, `NotDynReading` and `NotDynTemp` from `../types/messages`.

2. Export `displayReadingResults(sensor: SensorMetadata, reading: { ID: number; Serial: string; Time: string }, waveforms: WaveformData, temperature?: number): void`

   This single function handles all OUT requirements:

   **OUT-01: Sensor metadata**
   ```
   console.log('\n=== Sensor Information ===');
   console.log(`  Serial:    ${sensor.Serial}`);
   console.log(`  Part:      ${sensor.PartNum}`);
   console.log(`  ReadRate:  ${sensor.ReadRate} Hz`);
   console.log(`  Samples:   ${sensor.Samples}`);
   ```
   Include GMode if present: `if (sensor.GMode !== undefined) console.log(\`  GMode:     ${sensor.GMode}\`);`

   **OUT-02: Reading metadata**
   ```
   console.log('\n=== Reading Information ===');
   console.log(`  Reading ID: ${reading.ID}`);
   console.log(`  Serial:     ${reading.Serial}`);
   console.log(`  Timestamp:  ${reading.Time}`);
   ```

   **OUT-03: Waveform statistics (samples per axis)**
   ```
   console.log('\n=== Waveform Statistics ===');
   console.log(`  Samples per axis: X=${waveforms.x.length}, Y=${waveforms.y.length}, Z=${waveforms.z.length}`);
   ```

   **OUT-05: Min/max/mean per axis** - Call calculateAxisStats for each axis:
   ```
   const xStats = calculateAxisStats(waveforms.x);
   const yStats = calculateAxisStats(waveforms.y);
   const zStats = calculateAxisStats(waveforms.z);
   console.log(`  X-axis: min=${xStats.min.toFixed(4)}, max=${xStats.max.toFixed(4)}, mean=${xStats.mean.toFixed(4)}`);
   console.log(`  Y-axis: min=${yStats.min.toFixed(4)}, max=${yStats.max.toFixed(4)}, mean=${yStats.mean.toFixed(4)}`);
   console.log(`  Z-axis: min=${zStats.min.toFixed(4)}, max=${zStats.max.toFixed(4)}, mean=${zStats.mean.toFixed(4)}`);
   ```

   **OUT-04: First 10 samples per axis**
   ```
   console.log('\n=== First 10 Samples ===');
   const sampleCount = Math.min(10, waveforms.x.length);
   for (let i = 0; i < sampleCount; i++) {
     console.log(`  [${String(i).padStart(2)}]  X=${waveforms.x[i].toFixed(4)}  Y=${waveforms.y[i].toFixed(4)}  Z=${waveforms.z[i].toFixed(4)}`);
   }
   ```

   **OUT-06: Temperature if present**
   ```
   if (temperature !== undefined) {
     console.log(`\n=== Temperature ===`);
     console.log(`  Temperature: ${temperature} C`);
   }
   ```

Use simple console.log formatting (not console.table) for reliable, clean output. Use toFixed(4) for numeric precision.
  </action>
  <verify>
`npx tsc --noEmit` compiles without errors. File exists at src/output/waveform-display.ts. Exports displayReadingResults function.
  </verify>
  <done>
Display module outputs sensor metadata (OUT-01), reading metadata (OUT-02), sample counts (OUT-03), first 10 samples (OUT-04), min/max/mean statistics (OUT-05), and temperature when present (OUT-06). All formatting uses fixed decimal precision.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Both files exist in their respective directories
3. waveform-parser.ts exports: WaveformData, parseWaveform, calculateAxisStats
4. waveform-display.ts exports: displayReadingResults
5. No new dependencies added (all native Node.js + existing imports)
</verification>

<success_criteria>
- Progressive waveform parser implements CSV, JSON, Base64 strategies with validation
- Statistics calculator handles min/max/mean/count correctly
- Display function covers all OUT-01 through OUT-06 requirements
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-acquisition-and-notifications/05-01-SUMMARY.md`
</output>
