---
phase: 08-repository-layer
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/utils/encryption.ts
autonomous: true

must_haves:
  truths:
    - "Encryption key loads from ENCRYPTION_KEY environment variable"
    - "Passwords encrypt with AES-256-GCM producing unique ciphertext each time (random IV)"
    - "Encrypted passwords decrypt back to original plaintext successfully"
    - "Encryption rejects empty plaintext, invalid keys, and tampered data"
    - "Round-trip encrypt/decrypt works for any UTF-8 string"
  artifacts:
    - path: "src/utils/encryption.ts"
      provides: "AES-256-GCM encrypt/decrypt utilities and key management"
      exports: ["encryptPassword", "decryptPassword", "getEncryptionKey", "testEncryptionRoundTrip", "EncryptedData"]
  key_links:
    - from: "src/utils/encryption.ts"
      to: "process.env.ENCRYPTION_KEY"
      via: "getEncryptionKey reads environment variable"
      pattern: "process\\.env\\.ENCRYPTION_KEY"
---

<objective>
Build AES-256-GCM encryption utilities for gateway password storage using TDD approach.

Purpose: Gateway passwords must be encrypted before database storage and decrypted when connecting to gateways. This is security-critical code that benefits from test-first design to ensure correctness, edge case handling, and round-trip fidelity.

Output: Tested encryption module with encrypt, decrypt, key management, and round-trip validation functions.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-repository-layer/08-RESEARCH.md
</context>

<feature>
  <name>AES-256-GCM Password Encryption Utilities</name>
  <files>src/utils/encryption.ts, src/utils/encryption.test.ts</files>
  <behavior>
  Expected behavior in testable terms:

  **encryptPassword(plaintext, key) -> EncryptedData:**
  - "password123" + valid 32-byte key -> { encrypted: base64, iv: base64, authTag: base64 }
  - Same plaintext encrypted twice -> different encrypted output (random IV)
  - Empty string input -> throws Error("Plaintext cannot be empty")
  - Key with wrong length (not 32 bytes) -> throws Error about key length

  **decryptPassword(encryptedData, key) -> string:**
  - encryptPassword("password123", key) result + same key -> "password123"
  - Modified encrypted field -> throws (auth tag verification fails)
  - Modified authTag -> throws (auth tag verification fails)
  - Wrong key -> throws (decryption fails)
  - Missing fields in EncryptedData -> throws Error("Invalid encrypted data structure")

  **getEncryptionKey() -> Buffer:**
  - ENCRYPTION_KEY env var set with valid base64 32-byte key -> Buffer of 32 bytes
  - ENCRYPTION_KEY env var not set -> throws Error about missing env var
  - ENCRYPTION_KEY set but not valid base64 -> throws Error about invalid format
  - ENCRYPTION_KEY set but wrong length -> throws Error about key length

  **testEncryptionRoundTrip(key) -> boolean:**
  - Valid key -> returns true (internal encrypt then decrypt succeeds)
  - Invalid key -> throws (from encrypt or decrypt)

  **EncryptedData interface:**
  - { encrypted: string, iv: string, authTag: string } - all base64 encoded strings
  </behavior>
  <implementation>
  Use Node.js built-in `crypto` module (no external dependencies):
  - Algorithm: 'aes-256-gcm'
  - IV length: 12 bytes (96 bits, recommended for GCM)
  - Key length: 32 bytes (256 bits)
  - Generate random IV with `randomBytes(12)` for EVERY encryption (CRITICAL: never reuse IV)
  - Use `createCipheriv` / `createDecipheriv` (NOT deprecated createCipher/createDecipher)
  - Store encrypted data as base64, IV as base64, authTag as base64
  - Key loaded from environment variable `ENCRYPTION_KEY` as base64-encoded string
  - Key generation command: `openssl rand -base64 32`

  Input validation:
  - Reject empty plaintext
  - Validate key is exactly 32 bytes
  - Validate EncryptedData has all required fields before decryption

  See 08-RESEARCH.md Pattern 5 for complete code example.

  **Testing setup:** If no test runner is installed, install vitest as dev dependency for this TDD plan. Configure in package.json with a "test" script. Keep test configuration minimal.
  </implementation>
</feature>

<verification>
1. All tests pass: `npm test` or test runner equivalent
2. `npm run build` compiles without errors
3. Round-trip test: encrypt("test-password") then decrypt -> "test-password"
4. Two encryptions of same plaintext produce different ciphertext (IV uniqueness)
5. Tampered ciphertext throws on decrypt (GCM authentication)
</verification>

<success_criteria>
- encryptPassword produces EncryptedData with encrypted, iv, authTag (all base64)
- decryptPassword recovers original plaintext from EncryptedData
- Each encryption generates unique random IV (same input -> different output)
- getEncryptionKey loads and validates key from ENCRYPTION_KEY env var
- testEncryptionRoundTrip confirms encrypt/decrypt cycle works
- Edge cases handled: empty input, wrong key length, tampered data, missing env var
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-repository-layer/08-02-SUMMARY.md`
</output>
