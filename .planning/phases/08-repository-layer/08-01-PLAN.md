---
phase: 08-repository-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/database/kysely.ts
  - src/database/types.ts
  - src/repositories/types.ts
  - package.json
  - .env.example
  - .kysely-codegenrc.json
autonomous: true

must_haves:
  truths:
    - "Kysely connects to PostgreSQL and generates type-safe query builders for all three tables"
    - "kysely-codegen generates Database interface from running database schema"
    - "npm run db:migrate automatically triggers type generation after migrations run"
    - "Generated types are committed to git and reflect actual database schema"
    - "Zod schemas validate repository query results at runtime"
  artifacts:
    - path: "src/database/kysely.ts"
      provides: "Kysely singleton instance with PostgresDialect and connection pool"
      exports: ["db", "closeDatabase"]
    - path: "src/database/types.ts"
      provides: "Generated Database interface from kysely-codegen"
      contains: "Database"
    - path: "src/repositories/types.ts"
      provides: "Zod schemas for Factory and Gateway query results, and typed aliases"
      contains: "FactorySchema"
    - path: ".kysely-codegenrc.json"
      provides: "kysely-codegen configuration"
      contains: "postgres"
  key_links:
    - from: "src/database/kysely.ts"
      to: "src/database/types.ts"
      via: "Kysely<Database> generic parameter"
      pattern: "Kysely<Database>"
    - from: "src/database/kysely.ts"
      to: "src/database/config.ts"
      via: "imports databaseConfig for pool connection"
      pattern: "import.*databaseConfig.*config"
    - from: "package.json"
      to: "src/database/types.ts"
      via: "db:migrate chains db:codegen to regenerate types"
      pattern: "db:codegen"
---

<objective>
Set up Kysely connection pool, configure automatic type generation from database schema, and define Zod runtime validation schemas for repository results.

Purpose: Establishes the type-safe database access foundation that repositories (Plan 03) will build on. Ensures both compile-time safety (generated types) and runtime safety (Zod schemas) per user decision.

Output: Kysely singleton, generated Database interface, Zod validation schemas, updated npm scripts.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-repository-layer/08-RESEARCH.md
@.planning/phases/07-database-setup/07-01-SUMMARY.md
@.planning/phases/07-database-setup/07-02-SUMMARY.md
@src/database/config.ts
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Kysely and configure type generation</name>
  <files>
    package.json
    .kysely-codegenrc.json
    .env.example
  </files>
  <action>
Install dependencies:
```bash
npm install kysely
npm install --save-dev kysely-codegen
```

Create `.kysely-codegenrc.json` in project root:
```json
{
  "dialect": "postgres",
  "outFile": "src/database/types.ts",
  "camelCase": false
}
```

Update `package.json` scripts:
- Change `"db:migrate"` from `"tsx node_modules/.bin/node-pg-migrate up"` to `"tsx node_modules/.bin/node-pg-migrate up && npm run db:codegen"` (user decision: auto-generate types after migrations)
- Add `"db:codegen": "kysely-codegen"` script (uses .kysely-codegenrc.json for config)

Add `ENCRYPTION_KEY` to `.env.example` with a comment explaining how to generate it:
```
# Encryption key for gateway passwords (32 bytes, base64 encoded)
# Generate with: openssl rand -base64 32
ENCRYPTION_KEY=
```

Then run type generation (requires database to be running):
```bash
npm run db:codegen
```

This generates `src/database/types.ts` from the running PostgreSQL schema. Inspect the output to verify it includes Database interface with organizations, factories, and gateways tables.
  </action>
  <verify>
1. `npm run db:codegen` completes without errors
2. `src/database/types.ts` exists and contains `Database` interface with `organizations`, `factories`, `gateways` table types
3. `npm run build` still compiles (no type errors introduced)
  </verify>
  <done>kysely and kysely-codegen installed, type generation produces Database interface matching schema, db:migrate triggers codegen automatically</done>
</task>

<task type="auto">
  <name>Task 2: Create Kysely singleton and Zod validation schemas</name>
  <files>
    src/database/kysely.ts
    src/repositories/types.ts
  </files>
  <action>
Create `src/database/kysely.ts` - Kysely singleton instance:
- Import `Kysely`, `PostgresDialect` from 'kysely'
- Import `Pool` from 'pg'
- Import `Database` from './types' (generated types)
- Import `databaseConfig` from './config'
- Create single Kysely instance with PostgresDialect using pg Pool:
  - Pool configured from databaseConfig (host, port, database, user, password)
  - max: 10 connections
- Export `db` (the Kysely instance)
- Export `closeDatabase()` async function that calls `db.destroy()` for graceful shutdown

Create `src/repositories/types.ts` - Zod schemas and type aliases:
- Import `z` from 'zod', and `Selectable`, `Insertable`, `Updateable` from 'kysely'
- Import generated table types from '../database/types' (Organizations, Factories, Gateways)
- Define Kysely helper type aliases:
  - `Factory = Selectable<Factories>`, `NewFactory = Insertable<Factories>`, `FactoryUpdate = Updateable<Factories>`
  - `Gateway = Selectable<Gateways>`, `NewGateway = Insertable<Gateways>`, `GatewayUpdate = Updateable<Gateways>`
  - `Organization = Selectable<Organizations>` (for completeness)
- Define Zod schemas matching database table shapes for runtime validation:
  - `FactorySchema`: z.object with id (uuid), organization_id (uuid), name (string), location (string nullable), timezone (string), metadata (z.record), created_at (date), updated_at (date), deleted_at (date nullable)
  - `GatewaySchema`: z.object with all gateway columns (id, factory_id, gateway_id, name, url, email, password_encrypted, model nullable, firmware_version nullable, last_seen_at date nullable, metadata, timestamps, deleted_at nullable)
- Export all types and schemas

Note: The exact generated type names from kysely-codegen will determine the import names. Inspect `src/database/types.ts` after Task 1 to get the correct table interface names (likely `Organizations`, `Factories`, `Gateways` or similar). Adjust imports accordingly.
  </action>
  <verify>
1. `npm run build` compiles without errors
2. `src/database/kysely.ts` exports `db` and `closeDatabase`
3. `src/repositories/types.ts` exports Factory, Gateway, NewFactory, NewGateway, FactoryUpdate, GatewayUpdate types and FactorySchema, GatewaySchema Zod schemas
4. Kysely instance is typed with `Database` from generated types
  </verify>
  <done>Kysely singleton connects to PostgreSQL with type-safe Database generic, Zod schemas ready for runtime validation of query results, all type aliases exported for repository use</done>
</task>

</tasks>

<verification>
1. `npm run db:codegen` regenerates types from database
2. `npm run build` compiles without errors
3. Generated `src/database/types.ts` contains Database interface with all three tables
4. Kysely instance typed with `Kysely<Database>` providing autocomplete for table names
5. Zod schemas can validate objects matching database row shape
</verification>

<success_criteria>
- Kysely is installed and creates type-safe query builders from generated Database interface
- kysely-codegen generates types from running database (not migration files)
- `npm run db:migrate` automatically triggers type generation
- Generated types committed to git
- Zod schemas defined for Factory and Gateway runtime validation
- `npm run build` passes with all new files
</success_criteria>

<output>
After completion, create `.planning/phases/08-repository-layer/08-01-SUMMARY.md`
</output>
