---
phase: 02-connection-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/types/connection.ts
  - src/gateway/reconnect.ts
  - src/gateway/heartbeat.ts
autonomous: true

must_haves:
  truths:
    - "ConnectionState enum defines all lifecycle states (DISCONNECTED, CONNECTING, CONNECTED, AUTHENTICATED, CLOSING, CLOSED)"
    - "ExponentialBackoff calculates increasing delays capped at maxDelay with jitter"
    - "HeartbeatManager sends periodic heartbeats and detects timeout"
  artifacts:
    - path: "src/types/connection.ts"
      provides: "ConnectionState enum and connection-related types"
      exports: ["ConnectionState"]
      contains: "DISCONNECTED"
    - path: "src/gateway/reconnect.ts"
      provides: "ExponentialBackoff class and ReconnectionManager"
      exports: ["ExponentialBackoff", "ReconnectionManager"]
      contains: "getDelay"
    - path: "src/gateway/heartbeat.ts"
      provides: "HeartbeatManager for connection health monitoring"
      exports: ["HeartbeatManager"]
      contains: "start"
  key_links:
    - from: "src/gateway/reconnect.ts"
      to: "src/utils/logger.ts"
      via: "import logger"
      pattern: "import.*logger"
    - from: "src/gateway/heartbeat.ts"
      to: "src/utils/logger.ts"
      via: "import logger"
      pattern: "import.*logger"
---

<objective>
Install the ws WebSocket library and build the three foundation modules for connection management: ConnectionState types, ExponentialBackoff reconnection logic, and HeartbeatManager health monitoring.

Purpose: These are the building blocks that the WebSocketConnection class (Plan 02) will compose. Separating them into independent modules keeps each concern testable and maintainable.
Output: ws dependency installed, ConnectionState enum, ExponentialBackoff class, HeartbeatManager class.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-connection-management/02-RESEARCH.md

@src/config.ts
@src/utils/logger.ts
@src/types/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ws library and create ConnectionState types</name>
  <files>package.json, src/types/connection.ts</files>
  <action>
1. Install ws and its TypeScript definitions:
   ```bash
   npm install ws
   npm install -D @types/ws
   ```

2. Create `src/types/connection.ts` with:

   - `ConnectionState` enum with values: DISCONNECTED, CONNECTING, CONNECTED, AUTHENTICATED, CLOSING, CLOSED. Use string enum (e.g., `DISCONNECTED = 'DISCONNECTED'`) for readable logging.

   - `ReconnectConfig` interface with fields:
     - `initialDelay: number` (starting delay in ms)
     - `maxDelay: number` (maximum delay cap in ms)
     - `multiplier: number` (delay multiplier, typically 2)
     - `maxAttempts?: number` (optional limit on reconnection attempts)

   - `HeartbeatConfig` interface with fields:
     - `interval: number` (how often to send heartbeat in ms)
     - `timeout: number` (how long to wait for response in ms)

   - `ConnectionConfig` interface with fields:
     - `url: string` (WebSocket URL)
     - `reconnect: ReconnectConfig`
     - `heartbeat: HeartbeatConfig`

   Note: AUTHENTICATED state is defined here for state machine completeness but the actual transition to AUTHENTICATED will be implemented in Phase 4 (Authentication). For now, the state machine supports DISCONNECTED -> CONNECTING -> CONNECTED -> CLOSING -> CLOSED transitions.

3. Update `src/types/index.ts` to re-export everything from `./connection`:
   ```typescript
   export * from './connection';
   ```
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with zero errors.
Verify `ws` appears in package.json dependencies.
Verify `@types/ws` appears in package.json devDependencies.
  </verify>
  <done>
ws and @types/ws installed. ConnectionState enum, ReconnectConfig, HeartbeatConfig, and ConnectionConfig types exported from src/types/connection.ts. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ExponentialBackoff and ReconnectionManager</name>
  <files>src/gateway/reconnect.ts</files>
  <action>
Create `src/gateway/reconnect.ts` implementing exponential backoff with decorrelated jitter (AWS-recommended pattern from research).

**ExponentialBackoff class:**
- Constructor takes `ReconnectConfig` (import from `../types/connection`)
- Private `attempts: number = 0` tracking retry count
- `getDelay(): number` method:
  - Calculate base: `initialDelay * Math.pow(multiplier, attempts)`
  - Cap at `maxDelay`
  - Apply decorrelated jitter: `Math.random() * (cappedDelay * 3 - initialDelay) + initialDelay`
  - Final value: `Math.min(jitter, maxDelay)`
  - Increment attempts counter
  - Return `Math.floor(result)`
- `reset(): void` -- sets attempts back to 0
- `getAttempts(): number` -- returns current attempt count
- `hasExceededMaxAttempts(): boolean` -- returns false if maxAttempts not set, otherwise checks `attempts >= maxAttempts`

**ReconnectionManager class:**
- Constructor takes no arguments, creates internal ExponentialBackoff with defaults from research: `{ initialDelay: 1000, maxDelay: 30000, multiplier: 2 }`
- Private `reconnectTimer: NodeJS.Timeout | null = null`
- `scheduleReconnect(callback: () => void): void`:
  - Gets delay from backoff
  - Logs: `Scheduling reconnect attempt {N} in {delay}ms` using logger
  - Sets reconnectTimer with setTimeout
- `cancelReconnect(): void` -- clears reconnectTimer if set, sets to null
- `resetBackoff(): void` -- calls backoff.reset()
- `cleanup(): void` -- calls cancelReconnect() and resetBackoff()
- `isScheduled(): boolean` -- returns `reconnectTimer !== null`

Import logger from `../utils/logger`.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors.
Verify the file exports ExponentialBackoff and ReconnectionManager.
  </verify>
  <done>
ExponentialBackoff class implements decorrelated jitter algorithm with configurable initial/max/multiplier. ReconnectionManager wraps ExponentialBackoff with timer management and cleanup. Both compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement HeartbeatManager</name>
  <files>src/gateway/heartbeat.ts</files>
  <action>
Create `src/gateway/heartbeat.ts` implementing application-level heartbeat monitoring (preferred over protocol ping/pong per research).

**HeartbeatManager class:**
- Constructor takes `HeartbeatConfig` (import from `../types/connection`)
- Private fields:
  - `config: HeartbeatConfig`
  - `heartbeatTimer: NodeJS.Timeout | null = null`
  - `timeoutTimer: NodeJS.Timeout | null = null`
  - `onTimeoutCallback: (() => void) | null = null`

- `onTimeout(callback: () => void): void` -- registers callback for when heartbeat times out (connection considered dead)

- `start(sendFn: (message: string) => void): void`:
  - Logs: `Starting heartbeat (interval: {interval}ms, timeout: {timeout}ms)`
  - Sets heartbeatTimer with setInterval calling sendHeartbeat

- Private `sendHeartbeat(sendFn: (message: string) => void): void`:
  - Creates JSON message: `{ type: "ping", timestamp: Date.now() }`
  - Calls sendFn with JSON.stringify of message
  - Logs debug: `Sending heartbeat`
  - Sets timeoutTimer with setTimeout calling handleTimeout

- `handleHeartbeatResponse(): void` (public -- called by connection when pong received):
  - Clears timeoutTimer if set, sets to null
  - Logs debug: `Heartbeat response received`

- Private `handleTimeout(): void`:
  - Logs error: `Heartbeat timeout - connection considered dead`
  - Calls stop()
  - Calls onTimeoutCallback if set

- `stop(): void`:
  - Clears heartbeatTimer if set, sets to null
  - Clears timeoutTimer if set, sets to null
  - Logs info: `Heartbeat stopped`

- `isRunning(): boolean` -- returns `heartbeatTimer !== null`

Import logger from `../utils/logger`.

**Design note:** The sendFn parameter is a callback because HeartbeatManager should not depend directly on the WebSocket instance. The WebSocketConnection class (Plan 02) will pass its own send method when starting heartbeat. This keeps HeartbeatManager decoupled and testable.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors.
Verify the file exports HeartbeatManager.
  </verify>
  <done>
HeartbeatManager sends periodic JSON heartbeats via callback, detects missed responses with configurable timeout, and triggers onTimeout callback when connection is considered dead. All timers properly cleared on stop(). Compiles cleanly.
  </done>
</task>

</tasks>

<verification>
After all three tasks:
1. `npx tsc --noEmit` passes with zero errors
2. `src/types/connection.ts` exports ConnectionState enum with 6 states
3. `src/gateway/reconnect.ts` exports ExponentialBackoff and ReconnectionManager
4. `src/gateway/heartbeat.ts` exports HeartbeatManager
5. `package.json` includes ws in dependencies and @types/ws in devDependencies
6. All imports resolve correctly (logger, types)
</verification>

<success_criteria>
- ws library installed and importable
- ConnectionState enum available for import across the project
- ExponentialBackoff correctly computes increasing delays with jitter, capped at maxDelay
- ReconnectionManager schedules and cancels reconnection timers without leaks
- HeartbeatManager starts/stops cleanly, detects timeout, triggers callback
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-management/02-01-SUMMARY.md`
</output>
