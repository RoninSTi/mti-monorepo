---
phase: 02-connection-management
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/gateway/connection.ts
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "Application connects to gateway WebSocket at configured URL"
    - "Connection state transitions through DISCONNECTED -> CONNECTING -> CONNECTED on open"
    - "Connection handles close and error events with appropriate logging"
    - "Application automatically reconnects with exponential backoff on abnormal closure"
    - "Heartbeat detects dead connections and triggers reconnection"
    - "SIGINT/SIGTERM triggers graceful shutdown clearing all timers and closing WebSocket"
  artifacts:
    - path: "src/gateway/connection.ts"
      provides: "WebSocketConnection class with full lifecycle management"
      exports: ["WebSocketConnection"]
      min_lines: 80
    - path: "src/main.ts"
      provides: "Application entry with connection startup and shutdown handlers"
      contains: "SIGINT"
  key_links:
    - from: "src/gateway/connection.ts"
      to: "src/gateway/reconnect.ts"
      via: "ReconnectionManager composition"
      pattern: "ReconnectionManager"
    - from: "src/gateway/connection.ts"
      to: "src/gateway/heartbeat.ts"
      via: "HeartbeatManager composition"
      pattern: "HeartbeatManager"
    - from: "src/gateway/connection.ts"
      to: "src/types/connection.ts"
      via: "ConnectionState import"
      pattern: "ConnectionState"
    - from: "src/gateway/connection.ts"
      to: "ws"
      via: "WebSocket client"
      pattern: "import WebSocket from 'ws'"
    - from: "src/main.ts"
      to: "src/gateway/connection.ts"
      via: "WebSocketConnection instantiation and connect()"
      pattern: "WebSocketConnection"
    - from: "src/main.ts"
      to: "src/config.ts"
      via: "config.GATEWAY_URL for connection URL"
      pattern: "config\\.GATEWAY_URL"
---

<objective>
Implement the WebSocketConnection class that composes ExponentialBackoff, HeartbeatManager, and the ConnectionState machine into a complete connection lifecycle manager. Wire it into main.ts with graceful shutdown handling.

Purpose: This is the core deliverable of Phase 2 -- a reliable, self-healing WebSocket connection that the rest of the application (Phases 3-5) will use for all gateway communication.
Output: Working WebSocketConnection class, integrated main.ts with shutdown handlers.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-connection-management/02-RESEARCH.md
@.planning/phases/02-connection-management/02-01-SUMMARY.md

@src/config.ts
@src/utils/logger.ts
@src/types/connection.ts
@src/gateway/reconnect.ts
@src/gateway/heartbeat.ts
@src/main.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WebSocketConnection class</name>
  <files>src/gateway/connection.ts</files>
  <action>
Replace the Phase 1 stub in `src/gateway/connection.ts` with the full WebSocketConnection class.

**Imports:**
- `WebSocket` from 'ws'
- `ConnectionState`, `ConnectionConfig` from '../types/connection'
- `ReconnectionManager` from './reconnect'
- `HeartbeatManager` from './heartbeat'
- `logger` from '../utils/logger'

**WebSocketConnection class (exported):**

Private fields:
- `ws: WebSocket | null = null`
- `state: ConnectionState = ConnectionState.DISCONNECTED`
- `config: ConnectionConfig`
- `reconnectManager: ReconnectionManager`
- `heartbeatManager: HeartbeatManager`
- `isShuttingDown: boolean = false`
- `onMessageCallback: ((data: string) => void) | null = null`

Constructor(config: ConnectionConfig):
- Store config
- Create ReconnectionManager (new instance)
- Create HeartbeatManager with config.heartbeat
- Register heartbeat onTimeout callback that calls `this.handleHeartbeatTimeout()`

**Public methods:**

`getState(): ConnectionState` -- returns current state

`onMessage(callback: (data: string) => void): void` -- registers message callback for Phase 3+ to use

`connect(): void`:
- If isShuttingDown, log warn "Connection attempt ignored - shutting down" and return
- If state is not DISCONNECTED and not CLOSED, log warn "Connection attempt ignored - state: {state}" and return
- Call setState(CONNECTING)
- Create new WebSocket(config.url)
- Register event handlers: open -> handleOpen(), close -> handleClose(code, reason), error -> handleError(error), message -> handleMessage(data)

`send(message: string): boolean`:
- If ws is null or ws.readyState !== WebSocket.OPEN, log warn "Cannot send - connection not open (state: {state})" and return false
- Call ws.send(message)
- Return true

`close(code: number = 1000, reason: string = 'Normal closure'): void`:
- If ws is null, return
- Set isShuttingDown = true
- Call reconnectManager.cleanup()
- Call heartbeatManager.stop()
- Call setState(CLOSING)
- Call ws.close(code, reason)

`terminate(): void`:
- If ws is null, return
- Log warn "Terminating WebSocket connection (immediate)"
- Call heartbeatManager.stop()
- Call reconnectManager.cleanup()
- Call ws.terminate()
- Call setState(CLOSED)

**Private methods:**

`setState(newState: ConnectionState): void`:
- Store old state
- Set this.state = newState
- Log info: `Connection state: {oldState} -> {newState}`

`handleOpen(): void`:
- Log info "WebSocket connection established"
- Call setState(CONNECTED)
- Call reconnectManager.resetBackoff() (successful connection resets backoff)
- Start heartbeat: `this.heartbeatManager.start((msg) => this.send(msg))`

`handleClose(code: number, reason: Buffer): void`:
- Log info: `WebSocket closed: code={code}, reason="{reason.toString()}"`
- Call heartbeatManager.stop()
- Call setState(CLOSED)
- If isShuttingDown, log info "Shutdown complete - not reconnecting" and return
- Call shouldReconnect(code) and if true, call scheduleReconnect()

`handleError(error: Error): void`:
- Log error: `WebSocket error: {error.message}`
- Note: error event is always followed by close event in ws library, so no state change here

`handleMessage(data: WebSocket.RawData): void`:
- Convert to string: `const message = data.toString()`
- Try to parse as JSON to check for heartbeat response
- If parsed and message has `type === 'pong'`, call `heartbeatManager.handleHeartbeatResponse()` and return
- Log debug: `Received: {message}` (truncate to first 200 chars for debug log)
- If onMessageCallback is set, call it with message

`shouldReconnect(closeCode: number): boolean`:
- 1000 (Normal Closure): return false -- intentional disconnect
- 1008 (Policy Violation): return false -- application-level rejection
- All others: return true -- reconnectable
- Log the decision at debug level

`scheduleReconnect(): void`:
- Call setState(DISCONNECTED) (reset to DISCONNECTED before reconnect attempt)
- Call reconnectManager.scheduleReconnect(() => this.connect())

`handleHeartbeatTimeout(): void`:
- Log warn "Heartbeat timeout - connection dead, reconnecting"
- If state is CONNECTED or AUTHENTICATED:
  - Call ws.terminate() directly (not this.terminate() which sets isShuttingDown)
  - Call heartbeatManager.stop()
  - Call setState(CLOSED)
  - Call scheduleReconnect()
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors.
Verify the file exports WebSocketConnection.
Verify WebSocketConnection imports from reconnect.ts, heartbeat.ts, and types/connection.ts.
  </verify>
  <done>
WebSocketConnection class manages full lifecycle: connect with state machine transitions, close code-based reconnection logic, heartbeat integration for health monitoring, exponential backoff reconnection, and clean separation of concerns via composition with ReconnectionManager and HeartbeatManager. All timers cleared on close/terminate. Compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire connection into main.ts with graceful shutdown</name>
  <files>src/main.ts</files>
  <action>
Update `src/main.ts` to create a WebSocketConnection, connect to the gateway, and handle graceful shutdown on SIGINT/SIGTERM.

**Replace the existing main.ts content with:**

1. Keep existing imports (config, initLogger, logger)
2. Add imports:
   - `WebSocketConnection` from './gateway/connection'
   - `ConnectionConfig` from './types/connection'

3. Keep existing logger initialization and startup log

4. Build ConnectionConfig from the validated config:
   ```typescript
   const connectionConfig: ConnectionConfig = {
     url: config.GATEWAY_URL,
     reconnect: {
       initialDelay: 1000,
       maxDelay: 30000,
       multiplier: 2,
     },
     heartbeat: {
       interval: config.HEARTBEAT_INTERVAL,
       timeout: 5000,  // 5s timeout for heartbeat response
     },
   };
   ```

5. Create WebSocketConnection instance:
   ```typescript
   const connection = new WebSocketConnection(connectionConfig);
   ```

6. Register a temporary onMessage handler that logs received messages (Phase 3 will replace this with proper message routing):
   ```typescript
   connection.onMessage((data) => {
     logger.debug('Message received (unhandled):', data.substring(0, 200));
   });
   ```

7. Implement graceful shutdown function:
   ```typescript
   let isShuttingDown = false;

   function shutdown(signal: string): void {
     if (isShuttingDown) {
       logger.warn('Shutdown already in progress, forcing exit');
       process.exit(1);
     }
     isShuttingDown = true;
     logger.info(`Received ${signal} - starting graceful shutdown`);

     connection.close(1000, 'Application shutdown');

     // Give connection 2 seconds to close gracefully, then force exit
     setTimeout(() => {
       logger.warn('Graceful shutdown timeout - forcing exit');
       process.exit(1);
     }, 2000);
   }
   ```

8. Register signal handlers:
   ```typescript
   process.on('SIGINT', () => shutdown('SIGINT'));
   process.on('SIGTERM', () => shutdown('SIGTERM'));
   ```

9. Start the connection:
   ```typescript
   logger.info(`Connecting to gateway at ${config.GATEWAY_URL}`);
   connection.connect();
   ```

**Important:** Do NOT call process.exit(0) on successful close. The event loop will naturally exit when all timers are cleared and the WebSocket is closed. Only force exit on timeout or double-signal.

**Note on .env file:** The application needs a .env file to run. The existing .env.example documents all required variables. The user will need to create .env with their gateway IP before running. This is already established from Phase 1.
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- zero errors.
2. Run `npm run build` -- compiles successfully to dist/.
3. Verify main.ts imports WebSocketConnection and config correctly.
4. Verify SIGINT and SIGTERM handlers are registered.
5. Verify connection.connect() is called at the end of main.ts.
  </verify>
  <done>
main.ts creates WebSocketConnection from validated config, connects to gateway, handles SIGINT/SIGTERM with graceful 2-second shutdown timeout, and logs all lifecycle events. Application builds successfully. Ready for Phase 3 to add message routing via the onMessage callback.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` compiles successfully
3. Full import chain works: main.ts -> connection.ts -> reconnect.ts + heartbeat.ts + types/connection.ts
4. WebSocketConnection class composes ReconnectionManager and HeartbeatManager
5. main.ts registers SIGINT/SIGTERM handlers
6. All ConnectionState transitions logged via logger
7. No timer leaks: heartbeat and reconnect timers cleared on close/terminate/shutdown
</verification>

<success_criteria>
- WebSocketConnection manages state machine: DISCONNECTED -> CONNECTING -> CONNECTED (on open), CONNECTED -> CLOSING -> CLOSED (on close)
- Abnormal close codes (not 1000, not 1008) trigger automatic reconnection with exponential backoff
- Heartbeat sends periodic JSON pings, detects timeout, triggers reconnection
- SIGINT/SIGTERM stops heartbeat, cancels reconnection, closes WebSocket, exits cleanly
- Application builds and starts without TypeScript errors
- Phase 3 can use connection.onMessage() to receive gateway messages and connection.send() to send commands
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-management/02-02-SUMMARY.md`
</output>
