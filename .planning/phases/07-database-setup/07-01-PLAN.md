---
phase: 07-database-setup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - src/database/config.ts
  - .env.example
  - .gitignore
  - package.json
autonomous: true

must_haves:
  truths:
    - "PostgreSQL container starts and accepts connections on configured port"
    - "Database configuration loads from environment variables with validation"
    - "npm scripts exist for migrate, seed, reset, and docker lifecycle"
  artifacts:
    - path: "docker-compose.yml"
      provides: "PostgreSQL 15 service with health check, persistent volume, and environment-based config"
      contains: "postgres:15-alpine"
    - path: "src/database/config.ts"
      provides: "Database-specific configuration with Zod validation and DATABASE_URL construction"
      exports: ["databaseConfig", "DATABASE_URL"]
    - path: "package.json"
      provides: "npm scripts for database workflow"
      contains: "db:migrate"
    - path: ".env.example"
      provides: "Database environment variable documentation"
      contains: "DATABASE_HOST"
  key_links:
    - from: "docker-compose.yml"
      to: ".env.example"
      via: "environment variable references"
      pattern: "DATABASE_(HOST|PORT|NAME|USER|PASSWORD)"
    - from: "src/database/config.ts"
      to: "process.env"
      via: "Zod validation"
      pattern: "z\\.object.*DATABASE"
    - from: "package.json"
      to: "node-pg-migrate"
      via: "npm scripts"
      pattern: "node-pg-migrate"
---

<objective>
Set up PostgreSQL Docker infrastructure, database configuration, and npm scripts for the development workflow.

Purpose: Establishes the local database environment that migrations (Plan 02) will target. Without this, there is no database to migrate against.
Output: Running PostgreSQL container, validated database config module, and complete npm script workflow (migrate, seed, reset, docker lifecycle).
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-database-setup/07-RESEARCH.md
@src/config.ts
@package.json
@.env.example
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker Compose and database configuration</name>
  <files>
    docker-compose.yml
    src/database/config.ts
    .env.example
    .gitignore
  </files>
  <action>
    1. Create `docker-compose.yml` at project root:
       - Service: `postgres` using `postgres:15-alpine` image
       - Container name: `mti-wifi-db`
       - Restart policy: `unless-stopped`
       - Environment: POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD from env vars with defaults (mti_wifi, postgres, postgres)
       - Port mapping: `${DATABASE_PORT:-5432}:5432`
       - Volume: `postgres_data:/var/lib/postgresql/data` for persistence
       - Health check: `pg_isready` with 10s interval, 5s timeout, 5 retries
       - Network: `mti-network` (bridge driver)

    2. Create `src/database/config.ts`:
       - Define Zod schema for database env vars: DATABASE_HOST (default localhost), DATABASE_PORT (default 5432), DATABASE_NAME (default mti_wifi), DATABASE_USER (default postgres), DATABASE_PASSWORD (default postgres)
       - Export `databaseConfig` object from Zod parse of process.env
       - Export `DATABASE_URL` string constructed as `postgres://user:password@host:port/name`
       - This is a SEPARATE config from the existing gateway `src/config.ts` -- do NOT modify the existing config.ts

    3. Update `.env.example` -- APPEND database section below existing gateway config:
       ```
       # Database (Milestone v1.0)
       DATABASE_HOST=localhost
       DATABASE_PORT=5432
       DATABASE_NAME=mti_wifi
       DATABASE_USER=postgres
       DATABASE_PASSWORD=postgres
       ```

    4. Update `.gitignore` -- add `docker-compose.override.yml` line (for local overrides) if not already present. The existing .env is already gitignored.
  </action>
  <verify>
    - `docker compose config` validates the compose file without errors
    - `npx tsx -e "import { databaseConfig, DATABASE_URL } from './src/database/config'; console.log(DATABASE_URL)"` prints a valid postgres:// URL (run with --env-file=.env or set DATABASE_NAME manually)
    - `.env.example` contains both gateway and database sections
  </verify>
  <done>
    docker-compose.yml defines PostgreSQL 15 service with health check and volume. src/database/config.ts exports validated database config and DATABASE_URL. .env.example documents all required database environment variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Install dependencies and configure npm scripts</name>
  <files>
    package.json
  </files>
  <action>
    1. Install dependencies:
       - Production: `npm install pg`
       - Development: `npm install -D node-pg-migrate @types/pg`

    2. Add npm scripts to package.json:
       - `"db:migrate": "node-pg-migrate -j ts up"` -- run pending migrations (node-pg-migrate reads DATABASE_URL from env)
       - `"db:migrate:create": "node-pg-migrate create -j ts -m migrations"` -- create new migration file in migrations/ directory
       - `"db:seed": "tsx --env-file=.env src/database/seed.ts"` -- run seed script
       - `"db:reset": "tsx --env-file=.env src/database/reset.ts"` -- drop and recreate database, run migrations and seed (per user decision: single command reset flow)
       - `"docker:up": "docker compose up -d"` -- start PostgreSQL container
       - `"docker:down": "docker compose down"` -- stop container (preserve data)
       - `"docker:reset": "docker compose down -v && docker compose up -d"` -- destroy volume and restart fresh

    3. Create a `migrations/` directory at project root (empty, will be populated by Plan 02).

    4. Configure node-pg-migrate in package.json by adding a top-level key:
       ```json
       "node-pg-migrate": {
         "migration-file-language": "ts",
         "migrations-dir": "migrations",
         "template-file-name": null
       }
       ```
       This tells node-pg-migrate to use TypeScript and the migrations/ directory without needing CLI flags.

    NOTE: The `db:migrate` script needs DATABASE_URL set in the environment. For local dev, use: `DATABASE_URL=postgres://postgres:postgres@localhost:5432/mti_wifi npm run db:migrate`. The db:seed and db:reset scripts use --env-file=.env since they run tsx.
  </action>
  <verify>
    - `npm run db:migrate:create -- test-migration` creates a TypeScript migration file in `migrations/` directory (then delete the test file)
    - `node -e "require('pg')"` does not throw (pg installed)
    - package.json contains all 7 db/docker scripts
  </verify>
  <done>
    pg and node-pg-migrate installed. package.json has db:migrate, db:migrate:create, db:seed, db:reset, docker:up, docker:down, docker:reset scripts. node-pg-migrate configured to use TypeScript and migrations/ directory.
  </done>
</task>

</tasks>

<verification>
1. `docker compose up -d` starts PostgreSQL container successfully
2. `docker compose ps` shows postgres service healthy
3. `psql -h localhost -U postgres -d mti_wifi -c "SELECT 1"` connects successfully (or via docker exec)
4. All npm scripts exist in package.json
5. `src/database/config.ts` compiles without TypeScript errors
</verification>

<success_criteria>
- PostgreSQL 15 runs in Docker container with persistent volume and health check
- Database configuration validated via Zod and exports DATABASE_URL
- 7 npm scripts available for database and Docker workflow
- node-pg-migrate installed and configured for TypeScript migrations
- migrations/ directory exists at project root
</success_criteria>

<output>
After completion, create `.planning/phases/07-database-setup/07-01-SUMMARY.md`
</output>
