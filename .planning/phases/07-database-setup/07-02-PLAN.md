---
phase: 07-database-setup
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - migrations/1707345600001_create-organizations.ts
  - migrations/1707345600002_create-factories.ts
  - migrations/1707345600003_create-gateways.ts
  - src/database/seed.ts
  - src/database/reset.ts
autonomous: true

must_haves:
  truths:
    - "Migrations create organizations, factories, and gateways tables with all required columns"
    - "All tables have UUID primary keys, created_at, updated_at, deleted_at, and JSONB metadata"
    - "Foreign keys enforce factories->organizations and gateways->factories relationships"
    - "Indexes exist on all foreign key columns and soft delete columns"
    - "updated_at columns auto-update via PostgreSQL trigger on row modification"
    - "Seed data populates realistic test data for development"
    - "db:reset drops and recreates everything from scratch in a single command"
  artifacts:
    - path: "migrations/1707345600001_create-organizations.ts"
      provides: "Organizations table with UUID PK, name, soft delete, JSONB metadata, updated_at trigger function"
      contains: "createTable"
    - path: "migrations/1707345600002_create-factories.ts"
      provides: "Factories table with FK to organizations, location, timezone, soft delete"
      contains: "references"
    - path: "migrations/1707345600003_create-gateways.ts"
      provides: "Gateways table with FK to factories, gateway credentials, soft delete, connection tracking"
      contains: "password_encrypted"
    - path: "src/database/seed.ts"
      provides: "Realistic seed data for development and testing"
      contains: "INSERT INTO"
    - path: "src/database/reset.ts"
      provides: "Database reset script: drop tables, run migrations, seed"
      contains: "db:migrate"
  key_links:
    - from: "migrations/1707345600002_create-factories.ts"
      to: "migrations/1707345600001_create-organizations.ts"
      via: "foreign key reference"
      pattern: "references.*organizations"
    - from: "migrations/1707345600003_create-gateways.ts"
      to: "migrations/1707345600002_create-factories.ts"
      via: "foreign key reference"
      pattern: "references.*factories"
    - from: "src/database/seed.ts"
      to: "all three tables"
      via: "INSERT queries"
      pattern: "INSERT INTO (organizations|factories|gateways)"
    - from: "src/database/reset.ts"
      to: "npm scripts"
      via: "execSync calls"
      pattern: "db:migrate"
---

<objective>
Create database migration files for all three tables (organizations, factories, gateways) with complete schema, plus seed data and reset script.

Purpose: Establishes the data model that the repository layer (Phase 8) and API (Phases 9-11) will build upon. Every table, column, constraint, and index defined here directly supports the CRUD operations in later phases.
Output: Three migration files creating the complete schema, a seed script with realistic test data, and a database reset script for the single-command developer workflow.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-database-setup/07-RESEARCH.md
@.planning/phases/07-database-setup/07-01-SUMMARY.md
@src/database/config.ts
@docker-compose.yml
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration files for organizations, factories, and gateways</name>
  <files>
    migrations/1707345600001_create-organizations.ts
    migrations/1707345600002_create-factories.ts
    migrations/1707345600003_create-gateways.ts
  </files>
  <action>
    Create three migration files using node-pg-migrate TypeScript format. Use timestamp-based filenames per user decision. Each migration has `up()` only -- append-only strategy per user decision (down() should return undefined or not be exported; do NOT throw or return false as that causes runtime errors -- simply omit the down export).

    **Migration 1: `1707345600001_create-organizations.ts`**
    - Create the reusable `update_updated_at_column` trigger function (PL/pgSQL, CREATE OR REPLACE):
      ```sql
      BEGIN NEW.updated_at = NOW(); RETURN NEW; END;
      ```
    - Create `organizations` table:
      - `id`: uuid, primary key, default gen_random_uuid()
      - `name`: varchar(255), NOT NULL
      - `metadata`: jsonb, NOT NULL, default '{}'
      - `created_at`: timestamptz, NOT NULL, default NOW()
      - `updated_at`: timestamptz, NOT NULL, default NOW()
      - `deleted_at`: timestamptz, nullable (soft delete)
    - Add partial index on `deleted_at` WHERE deleted_at IS NULL (for active record queries)
    - Add index on `name` (query-heavy column)
    - Apply `update_updated_at_column` trigger to organizations table (BEFORE UPDATE, ROW level)

    **Migration 2: `1707345600002_create-factories.ts`**
    - Create `factories` table:
      - `id`: uuid, primary key, default gen_random_uuid()
      - `organization_id`: uuid, NOT NULL, references organizations(id) ON DELETE CASCADE
      - `name`: varchar(255), NOT NULL
      - `location`: varchar(500), nullable
      - `timezone`: varchar(100), NOT NULL, default 'UTC'
      - `metadata`: jsonb, NOT NULL, default '{}'
      - `created_at`: timestamptz, NOT NULL, default NOW()
      - `updated_at`: timestamptz, NOT NULL, default NOW()
      - `deleted_at`: timestamptz, nullable
    - CRITICAL: Index on `organization_id` (foreign key -- required for CASCADE performance)
    - Partial index on `deleted_at` WHERE deleted_at IS NULL
    - Index on `name` (query-heavy)
    - Apply `update_updated_at_column` trigger to factories table

    **Migration 3: `1707345600003_create-gateways.ts`**
    - Create `gateways` table:
      - `id`: uuid, primary key, default gen_random_uuid()
      - `factory_id`: uuid, NOT NULL, references factories(id) ON DELETE CASCADE
      - `gateway_id`: varchar(255), NOT NULL (external device identifier)
      - `name`: varchar(255), NOT NULL
      - `url`: varchar(500), NOT NULL (WebSocket URL, e.g., ws://192.168.1.100:5000)
      - `email`: varchar(255), NOT NULL (gateway login email)
      - `password_encrypted`: text, NOT NULL (AES-256-GCM encrypted, stored as base64)
      - `model`: varchar(100), nullable
      - `firmware_version`: varchar(50), nullable
      - `last_seen_at`: timestamptz, nullable (last successful connection/heartbeat)
      - `metadata`: jsonb, NOT NULL, default '{}'
      - `created_at`: timestamptz, NOT NULL, default NOW()
      - `updated_at`: timestamptz, NOT NULL, default NOW()
      - `deleted_at`: timestamptz, nullable
    - CRITICAL: Index on `factory_id` (foreign key -- CASCADE performance)
    - Unique partial index on `gateway_id` WHERE deleted_at IS NULL (prevent duplicate active gateways)
    - Partial index on `deleted_at` WHERE deleted_at IS NULL
    - Index on `last_seen_at` (monitoring/health check queries)
    - Apply `update_updated_at_column` trigger to gateways table
    - Do NOT add GIN index on metadata JSONB -- per research recommendation, defer until specific queries emerge

    **Important implementation notes:**
    - Import `MigrationBuilder` and `ColumnDefinitions` from 'node-pg-migrate'
    - Export `shorthands: ColumnDefinitions | undefined = undefined`
    - For default string values in column definitions, wrap in single quotes inside the string: `default: "'UTC'"` or `default: "'{}'"`
    - Use `pgm.func('gen_random_uuid()')` for UUID defaults
    - Use `pgm.func('NOW()')` for timestamp defaults
    - For the trigger function, use `pgm.createFunction()` with language: 'plpgsql' and replace: true
    - For triggers, use `pgm.createTrigger()` with when: 'BEFORE', operation: 'UPDATE', level: 'ROW'
  </action>
  <verify>
    1. Ensure PostgreSQL is running: `docker compose up -d` and wait for healthy
    2. Run migrations: `DATABASE_URL=postgres://postgres:postgres@localhost:5432/mti_wifi npm run db:migrate`
    3. Verify tables exist: `docker exec mti-wifi-db psql -U postgres -d mti_wifi -c "\dt"` shows organizations, factories, gateways, pgmigrations
    4. Verify columns: `docker exec mti-wifi-db psql -U postgres -d mti_wifi -c "\d organizations"` and same for factories, gateways
    5. Verify indexes: `docker exec mti-wifi-db psql -U postgres -d mti_wifi -c "\di"` shows all expected indexes
    6. Verify foreign keys: `docker exec mti-wifi-db psql -U postgres -d mti_wifi -c "SELECT conname, conrelid::regclass, confrelid::regclass FROM pg_constraint WHERE contype = 'f';"` shows factories->organizations and gateways->factories
    7. Verify trigger: `docker exec mti-wifi-db psql -U postgres -d mti_wifi -c "SELECT trigger_name, event_object_table FROM information_schema.triggers;"` shows update triggers on all 3 tables
    8. Verify updated_at trigger works: Insert a row, update it, confirm updated_at changed
  </verify>
  <done>
    Three migration files create organizations, factories, and gateways tables. All tables have UUID PKs (gen_random_uuid()), timestamptz timestamps, soft delete (deleted_at), JSONB metadata. Foreign keys with CASCADE deletes link factories->organizations and gateways->factories. Indexes cover all foreign keys, soft delete columns, and query-heavy fields. updated_at trigger auto-updates on row modification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create seed data script and database reset workflow</name>
  <files>
    src/database/seed.ts
    src/database/reset.ts
  </files>
  <action>
    1. Create `src/database/seed.ts`:
       - Import `Pool` from 'pg' and `databaseConfig` from './config'
       - Create a Pool connection using databaseConfig values
       - Use a transaction (BEGIN/COMMIT) to ensure atomicity
       - First TRUNCATE all tables (gateways, factories, organizations -- in reverse FK order) with CASCADE to clear existing data
       - Insert realistic seed data:
         - **1 organization**: "Acme Manufacturing"
         - **3 factories**:
           1. "Springfield Plant" - location "Building 3, Springfield, IL", timezone "America/Chicago", metadata with manager info
           2. "Detroit Assembly" - location "1200 Industrial Pkwy, Detroit, MI", timezone "America/Detroit", metadata with shift schedule
           3. "Austin Facility" - location "500 Tech Blvd, Austin, TX", timezone "America/Chicago", metadata (minimal)
         - **6 gateways** (2 per factory):
           - Springfield: "North Wing Gateway" (GW-SPR-001), "South Wing Gateway" (GW-SPR-002)
           - Detroit: "Main Floor Gateway" (GW-DET-001), "Assembly Line Gateway" (GW-DET-002)
           - Austin: "Lab Gateway" (GW-AUS-001), "Server Room Gateway" (GW-AUS-002)
           - Each with realistic ws:// URLs (different IPs), admin@example.com email
           - For `password_encrypted`: use a placeholder string like "PLACEHOLDER_ENCRYPTED_PASSWORD" with a comment noting this will use real encryption in Phase 8. Do NOT implement actual encryption in Phase 7.
           - Vary model values (CTC-GW-100, CTC-GW-200) and firmware versions
           - Set `last_seen_at` to null for some, recent timestamps for others
       - Use parameterized queries ($1, $2...) to prevent SQL injection
       - Log progress as seed runs (e.g., "Seeded 1 organization", "Seeded 3 factories", "Seeded 6 gateways")
       - Handle errors: ROLLBACK on failure, always close pool in finally block

    2. Create `src/database/reset.ts`:
       - Import `execSync` from 'child_process'
       - Import `databaseConfig, DATABASE_URL` from './config'
       - Import `Pool` from 'pg'
       - Steps (logged with console.log at each step):
         a. Connect to PostgreSQL default `postgres` database (not the app database)
         b. DROP DATABASE IF EXISTS the app database (databaseConfig.DATABASE_NAME)
         c. CREATE DATABASE the app database
         d. Close the pool connection
         e. Run migrations: `execSync('npm run db:migrate', { stdio: 'inherit', env: { ...process.env, DATABASE_URL } })`
         f. Run seed: `execSync('npm run db:seed', { stdio: 'inherit' })`
         g. Log "Database reset complete!"
       - Handle errors gracefully (log and exit with code 1)
       - IMPORTANT: When connecting to drop/create database, connect to the `postgres` database, not the app database (can't drop a database you're connected to)
  </action>
  <verify>
    1. Run seed against migrated database: `npm run db:seed`
    2. Verify data: `docker exec mti-wifi-db psql -U postgres -d mti_wifi -c "SELECT name FROM organizations;"` returns "Acme Manufacturing"
    3. Verify factories: `docker exec mti-wifi-db psql -U postgres -d mti_wifi -c "SELECT name, timezone FROM factories;"` returns 3 factories
    4. Verify gateways: `docker exec mti-wifi-db psql -U postgres -d mti_wifi -c "SELECT name, gateway_id, url FROM gateways;"` returns 6 gateways
    5. Verify FK integrity: `docker exec mti-wifi-db psql -U postgres -d mti_wifi -c "SELECT g.name, f.name as factory FROM gateways g JOIN factories f ON g.factory_id = f.id;"` returns correct associations
    6. Test full reset: `npm run db:reset` -- drops database, recreates, migrates, and seeds in one command
    7. Verify data after reset: same queries as steps 2-5 return correct data
  </verify>
  <done>
    Seed script populates 1 organization, 3 factories, and 6 gateways with realistic data. Reset script provides single-command workflow: drop database, create database, run migrations, seed data. Both scripts handle errors gracefully with proper cleanup.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, run the full Phase 7 verification:

1. **DB-01**: `docker compose ps` shows postgres healthy on configured port
2. **DB-02**: `\dt` in psql shows organizations, factories, gateways tables
3. **DB-03**: Each table has `id` (uuid PK), `deleted_at` (timestamptz nullable), `metadata` (jsonb NOT NULL)
4. **DB-04**: `\di` shows indexes on organization_id (factories), factory_id (gateways), deleted_at (all tables), name (organizations, factories), gateway_id unique partial, last_seen_at
5. **DB-05**: `pg_constraint` query shows foreign keys: factories.organization_id -> organizations.id, gateways.factory_id -> factories.id
6. **Trigger**: Update a row and verify updated_at changed automatically
7. **Seed**: All 3 tables populated with realistic data (1 org, 3 factories, 6 gateways)
8. **Reset**: `npm run db:reset` completes successfully and database is in clean seeded state
</verification>

<success_criteria>
- All three migration files apply without errors and create complete schema
- Organizations table: UUID PK, name, metadata (jsonb), timestamps, soft delete, updated_at trigger
- Factories table: UUID PK, organization_id FK with CASCADE, name, location, timezone, metadata, timestamps, soft delete, updated_at trigger
- Gateways table: UUID PK, factory_id FK with CASCADE, gateway_id (unique active), name, url, email, password_encrypted, model, firmware_version, last_seen_at, metadata, timestamps, soft delete, updated_at trigger
- Foreign key indexes exist on organization_id and factory_id
- Partial indexes exist on deleted_at columns (WHERE deleted_at IS NULL)
- Seed data provides realistic test data: 1 org, 3 factories, 6 gateways
- npm run db:reset drops and recreates everything in one command
</success_criteria>

<output>
After completion, create `.planning/phases/07-database-setup/07-02-SUMMARY.md`
</output>
