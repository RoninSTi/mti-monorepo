---
phase: 04-authentication-and-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/messages.ts
  - src/config.ts
  - src/gateway/authenticator.ts
  - src/gateway/connection.ts
autonomous: true

must_haves:
  truths:
    - "POST_LOGIN command is sent with email/password from config after connection opens"
    - "Authentication failure results in clear error message and connection closure"
    - "Connection transitions to AUTHENTICATED state only after successful auth"
    - "SENSOR_SERIAL config field is optional (not required for startup)"
  artifacts:
    - path: "src/gateway/authenticator.ts"
      provides: "authenticate() function using CommandClient"
      exports: ["authenticate"]
    - path: "src/types/messages.ts"
      provides: "SensorMetadataSchema with Connected field"
      contains: "Connected"
    - path: "src/config.ts"
      provides: "Optional SENSOR_SERIAL config field"
      contains: "optional()"
    - path: "src/gateway/connection.ts"
      provides: "markAuthenticated() and isAuthenticated() methods"
      contains: "markAuthenticated"
  key_links:
    - from: "src/gateway/authenticator.ts"
      to: "src/gateway/command-client.ts"
      via: "commandClient.sendCommand() with POST_LOGIN"
      pattern: "sendCommand.*POST_LOGIN"
    - from: "src/gateway/authenticator.ts"
      to: "src/config.ts"
      via: "config.GATEWAY_EMAIL and config.GATEWAY_PASSWORD"
      pattern: "GATEWAY_EMAIL|GATEWAY_PASSWORD"
---

<objective>
Create the authentication function and update foundational types for Phase 4.

Purpose: Establishes the authentication capability (POST_LOGIN via CommandClient) and updates SensorMetadata schema to include the Connected field needed for sensor filtering. Also makes SENSOR_SERIAL optional in config (per research recommendation) and adds state transition methods to WebSocketConnection.

Output: `src/gateway/authenticator.ts` with exported `authenticate()` function, updated `src/types/messages.ts` with Connected field in SensorMetadataSchema, updated `src/config.ts` with optional SENSOR_SERIAL, and `src/gateway/connection.ts` with `markAuthenticated()`/`isAuthenticated()` methods.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-authentication-and-discovery/04-RESEARCH.md

@src/types/messages.ts
@src/types/connection.ts
@src/config.ts
@src/gateway/connection.ts
@src/gateway/command-client.ts
@src/utils/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update SensorMetadata schema and config</name>
  <files>src/types/messages.ts, src/config.ts</files>
  <action>
  In `src/types/messages.ts`, update the `SensorMetadataSchema` to explicitly include the fields from the requirements (DISC-03). The current schema only has Serial, PartNum, ReadRate, Samples, and optional Name. Add the missing fields:

  ```typescript
  export const SensorMetadataSchema = z.object({
    Serial: z.number(),
    Connected: z.number(),  // 1 = connected, 0 = disconnected
    AccessPoint: z.string().optional(),
    PartNum: z.string(),
    ReadRate: z.number(),
    GMode: z.number().optional(),
    FreqMode: z.number().optional(),
    ReadPeriod: z.number().optional(),
    Samples: z.number(),
    HwVer: z.string().optional(),
    FmVer: z.string().optional(),
    Name: z.string().optional(),
  }).passthrough(); // Keep passthrough for undocumented fields
  ```

  Key decisions:
  - `Connected` is required (z.number()) because it is critical for filtering -- every sensor entry must have it.
  - Most other fields are optional because gateway may not return all fields for every sensor.
  - `Serial`, `PartNum`, `ReadRate`, `Samples` remain required (already were).
  - Keep `.passthrough()` for forward compatibility (decision from Phase 3).

  In `src/config.ts`, change SENSOR_SERIAL from required string to optional number:

  ```typescript
  SENSOR_SERIAL: z.coerce.number().optional(),
  ```

  This changes it from `z.string().min(1)` to `z.coerce.number().optional()` because:
  - Research says SENSOR_SERIAL should be optional (use first available if not specified)
  - Serial numbers in SensorMetadata are `z.number()`, so config should match for comparison
  - `z.coerce.number()` handles string env vars being coerced to number
  - The Config type will change: `SENSOR_SERIAL` becomes `number | undefined`
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no type errors. The Config type change from `string` to `number | undefined` should not break anything because SENSOR_SERIAL is only referenced in config logging in main.ts (and that will still work with number | undefined).
  </verify>
  <done>
  SensorMetadataSchema includes Connected field (required, z.number()) plus all DISC-03 fields. Config SENSOR_SERIAL is optional number. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create authenticate function and add connection state methods</name>
  <files>src/gateway/authenticator.ts, src/gateway/connection.ts</files>
  <action>
  **Part A: Add markAuthenticated() and isAuthenticated() to WebSocketConnection**

  In `src/gateway/connection.ts`, add two public methods:

  ```typescript
  /**
   * Mark connection as authenticated after POST_LOGIN succeeds.
   * Only valid transition: CONNECTED -> AUTHENTICATED.
   */
  markAuthenticated(): void {
    if (this.state !== ConnectionState.CONNECTED) {
      logger.warn(`Cannot mark authenticated from state: ${this.state}`);
      return;
    }
    this.setState(ConnectionState.AUTHENTICATED);
  }

  /**
   * Check if connection is authenticated
   */
  isAuthenticated(): boolean {
    return this.state === ConnectionState.AUTHENTICATED;
  }
  ```

  Place these methods after the existing `getState()` and `onMessage()` methods (around line 38). The `markAuthenticated()` method validates the state transition -- you can only authenticate from CONNECTED state. This prevents double-authentication or authenticating from wrong states.

  **Part B: Create src/gateway/authenticator.ts**

  Create a new file with an exported `authenticate()` async function:

  ```typescript
  import type { CommandClient } from './command-client';
  import type { Config } from '../config';
  import { logger } from '../utils/logger';

  const AUTH_TIMEOUT_MS = 10_000; // 10 second auth timeout (industry best practice)

  /**
   * Authenticate with gateway using POST_LOGIN command.
   *
   * Sends credentials from config immediately after connection opens.
   * Uses a shorter timeout (10s) than default command timeout because
   * authentication should be fast.
   *
   * @param commandClient - Command client for sending POST_LOGIN
   * @param config - Application config with GATEWAY_EMAIL and GATEWAY_PASSWORD
   * @returns Response data from POST_LOGIN (structure unknown, logged for discovery)
   * @throws Error if authentication fails (RTN_ERR) or times out
   */
  export async function authenticate(
    commandClient: CommandClient,
    config: Config
  ): Promise<unknown> {
    logger.info(`Authenticating with gateway as ${config.GATEWAY_EMAIL}`);

    try {
      const responseData = await commandClient.sendCommand(
        {
          Type: 'POST_LOGIN',
          From: 'UI',
          To: 'SERV',
          Data: {
            Email: config.GATEWAY_EMAIL,
            Password: config.GATEWAY_PASSWORD,
          },
        },
        AUTH_TIMEOUT_MS
      );

      logger.info('Authentication successful');
      // Log response data at debug level to discover POST_LOGIN response structure
      // (Open question from research: exact RTN_DYN structure for POST_LOGIN unknown)
      logger.debug('POST_LOGIN response data:', responseData);

      return responseData;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logger.error(`Authentication failed: ${message}`);

      // Provide actionable guidance for credential errors
      if (message.includes('Invalid') || message.includes('credential')) {
        logger.error('Check GATEWAY_EMAIL and GATEWAY_PASSWORD in .env file');
      }

      throw error; // Re-throw for caller to handle (close connection, exit)
    }
  }
  ```

  Key design decisions:
  - 10-second timeout (not default 30s) because auth should be fast. Research recommends this.
  - Returns `unknown` because POST_LOGIN response structure is an open question. We log it at debug level for discovery during Phase 6 testing.
  - Does NOT log the password. Logs email only (not sensitive). CommandClient already avoids logging Data fields.
  - Re-throws errors so the caller (main.ts in Plan 02) can decide what to do (close connection, exit with code 1).
  - Does NOT call `markAuthenticated()` itself -- that's the caller's responsibility to keep this function focused on the command only.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no type errors. Verify the new file exists: `ls src/gateway/authenticator.ts`. Verify connection.ts has the new methods: search for "markAuthenticated" in the file.
  </verify>
  <done>
  `authenticate()` function exported from `src/gateway/authenticator.ts`. Sends POST_LOGIN with email/password from config, 10s timeout, logs success/failure without exposing password. `WebSocketConnection` has `markAuthenticated()` (validates CONNECTED -> AUTHENTICATED transition) and `isAuthenticated()` methods. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/gateway/authenticator.ts` exists and exports `authenticate` function
3. `src/types/messages.ts` SensorMetadataSchema includes `Connected: z.number()`
4. `src/config.ts` SENSOR_SERIAL uses `z.coerce.number().optional()`
5. `src/gateway/connection.ts` has `markAuthenticated()` and `isAuthenticated()` methods
6. Existing tests still pass: `npx vitest run` (if test infrastructure exists)
</verification>

<success_criteria>
- SensorMetadata type includes all DISC-03 fields (Serial, Connected, AccessPoint, PartNum, ReadRate, GMode, FreqMode, ReadPeriod, Samples, HwVer, FmVer)
- SENSOR_SERIAL config is optional (application starts without it)
- authenticate() sends POST_LOGIN with correct structure via CommandClient
- authenticate() uses 10s timeout, not default 30s
- authenticate() logs email but never password
- markAuthenticated() only transitions from CONNECTED state
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-and-discovery/04-01-SUMMARY.md`
</output>
