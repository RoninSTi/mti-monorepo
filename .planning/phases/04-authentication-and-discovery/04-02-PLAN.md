---
phase: 04-authentication-and-discovery
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/gateway/sensor-discovery.ts
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "Application sends GET_DYN_CONNECTED and receives sensor metadata dictionary"
    - "Application parses sensor fields and filters for connected sensors (Connected === 1)"
    - "Application selects first connected sensor or preferred sensor from config"
    - "Application handles no-sensors-connected case with warning and graceful exit"
    - "Application orchestrates full flow: connect -> authenticate -> discover -> (ready for Phase 5)"
  artifacts:
    - path: "src/gateway/sensor-discovery.ts"
      provides: "discoverSensor() function for sensor discovery and selection"
      exports: ["discoverSensor"]
    - path: "src/main.ts"
      provides: "Full application flow: connect, authenticate, discover sensor"
      contains: "authenticate"
  key_links:
    - from: "src/gateway/sensor-discovery.ts"
      to: "src/gateway/command-client.ts"
      via: "commandClient.sendCommand() with GET_DYN_CONNECTED"
      pattern: "sendCommand.*GET_DYN_CONNECTED"
    - from: "src/gateway/sensor-discovery.ts"
      to: "src/types/messages.ts"
      via: "SensorMetadataSchema.safeParse for each dictionary entry"
      pattern: "SensorMetadataSchema\\.safeParse"
    - from: "src/main.ts"
      to: "src/gateway/authenticator.ts"
      via: "authenticate() call after connection opens"
      pattern: "authenticate\\("
    - from: "src/main.ts"
      to: "src/gateway/sensor-discovery.ts"
      via: "discoverSensor() call after authentication succeeds"
      pattern: "discoverSensor\\("
    - from: "src/main.ts"
      to: "src/gateway/connection.ts"
      via: "connection.markAuthenticated() after successful auth"
      pattern: "markAuthenticated\\("
---

<objective>
Create the sensor discovery function and wire the complete authentication + discovery flow into main.ts.

Purpose: Completes Phase 4 by implementing sensor discovery (GET_DYN_CONNECTED parsing, Connected filtering, preferred sensor selection) and wiring the full application flow: connect -> authenticate -> transition to AUTHENTICATED -> discover sensors -> select sensor -> (ready for Phase 5 acquisition). Handles edge cases: auth failure exits with code 1, no sensors exits with code 0.

Output: `src/gateway/sensor-discovery.ts` with exported `discoverSensor()` function, and updated `src/main.ts` with complete orchestration flow.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-authentication-and-discovery/04-RESEARCH.md
@.planning/phases/04-authentication-and-discovery/04-01-SUMMARY.md

@src/types/messages.ts
@src/config.ts
@src/gateway/connection.ts
@src/gateway/command-client.ts
@src/gateway/authenticator.ts
@src/gateway/message-router.ts
@src/gateway/notification-handler.ts
@src/main.ts
@src/utils/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sensor discovery function</name>
  <files>src/gateway/sensor-discovery.ts</files>
  <action>
  Create `src/gateway/sensor-discovery.ts` with an exported `discoverSensor()` async function.

  ```typescript
  import type { CommandClient } from './command-client';
  import type { SensorMetadata } from '../types/messages';
  import { SensorMetadataSchema } from '../types/messages';
  import { logger } from '../utils/logger';

  /**
   * Discover connected sensors and select one for acquisition.
   *
   * Sends GET_DYN_CONNECTED to query all known sensors from gateway.
   * Response Data is a dictionary: { [serialString]: SensorMetadata, ... }
   * Each entry is validated individually with safeParse (invalid entries logged, not fatal).
   * Filters for Connected === 1, then selects preferred or first.
   *
   * @param commandClient - Authenticated command client
   * @param preferredSerial - Optional sensor serial number to prefer (from config)
   * @returns Selected connected sensor metadata
   * @throws Error if no sensors are connected (caller should handle gracefully)
   */
  export async function discoverSensor(
    commandClient: CommandClient,
    preferredSerial?: number
  ): Promise<SensorMetadata> {
    logger.info('Discovering connected sensors...');

    const responseData = await commandClient.sendCommand({
      Type: 'GET_DYN_CONNECTED',
      From: 'UI',
      To: 'SERV',
      Data: {},
    });

    // responseData is Record<string, unknown> from RTN_DYN.Data
    // Each key is a sensor serial (as string), value is sensor metadata object
    const allSensors: SensorMetadata[] = [];

    if (responseData && typeof responseData === 'object') {
      for (const [serialKey, metadata] of Object.entries(responseData)) {
        const parsed = SensorMetadataSchema.safeParse(metadata);
        if (parsed.success) {
          allSensors.push(parsed.data);
          logger.debug(`Sensor ${serialKey}: Connected=${parsed.data.Connected}, PartNum=${parsed.data.PartNum}`);
        } else {
          logger.warn(`Invalid sensor metadata for serial ${serialKey}: ${parsed.error.message}`);
        }
      }
    }

    // Filter for connected sensors only (DISC-04: Connected === 1)
    const connectedSensors = allSensors.filter(s => s.Connected === 1);

    logger.info(`Found ${connectedSensors.length} connected sensor(s) out of ${allSensors.length} total`);

    // DISC-05: Handle no sensors connected
    if (connectedSensors.length === 0) {
      throw new Error('No sensors currently connected to gateway');
    }

    // DISC-04: Select preferred sensor from config, or first connected
    let selected: SensorMetadata;

    if (preferredSerial !== undefined) {
      const preferred = connectedSensors.find(s => s.Serial === preferredSerial);
      if (preferred) {
        selected = preferred;
        logger.info(`Selected preferred sensor: Serial=${selected.Serial}`);
      } else {
        selected = connectedSensors[0];
        logger.warn(
          `Preferred sensor ${preferredSerial} not found or not connected, using first available: Serial=${selected.Serial}`
        );
      }
    } else {
      selected = connectedSensors[0];
      logger.info(`Selected first connected sensor: Serial=${selected.Serial}`);
    }

    // Log selected sensor details (DISC-03 fields)
    logger.info(`Sensor: Serial=${selected.Serial}, PartNum=${selected.PartNum}, ReadRate=${selected.ReadRate}Hz, Samples=${selected.Samples}`);

    return selected;
  }
  ```

  Key decisions:
  - Uses `SensorMetadataSchema.safeParse()` per entry (not z.record()) because invalid entries should be logged individually without failing the entire discovery.
  - Filters `Connected === 1` after parsing (not before), so we can report total vs connected counts.
  - If `preferredSerial` is specified but not connected, falls back to first available with a WARN log (per research recommendation).
  - Throws Error on zero connected sensors -- caller (main.ts) decides whether this is exit(0) or exit(1).
  - Does NOT import or use config directly -- receives `preferredSerial` as parameter for testability.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no type errors. Verify the file exists: `ls src/gateway/sensor-discovery.ts`. Verify it exports discoverSensor.
  </verify>
  <done>
  `discoverSensor()` function exported from `src/gateway/sensor-discovery.ts`. Sends GET_DYN_CONNECTED via CommandClient, parses each sensor entry with SensorMetadataSchema.safeParse(), filters for Connected === 1, selects preferred or first, throws on empty. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire authentication and discovery flow into main.ts</name>
  <files>src/main.ts</files>
  <action>
  Rewrite `src/main.ts` to orchestrate the full connect -> authenticate -> discover flow. The current main.ts calls `connection.connect()` and that is it. The new main.ts needs to:

  1. Keep all existing setup (config, logger, connection, commandClient, messageRouter, notificationHandler, signal handlers)
  2. Add a mechanism to detect when the connection opens so we can start the auth/discovery flow
  3. Run the async flow: authenticate -> markAuthenticated -> discoverSensor -> log ready state

  **Critical design decision: How to detect connection open?**

  The WebSocketConnection class does not currently expose a Promise or callback for the 'open' event. The connection.connect() method is synchronous (returns void). We need to know when the connection is CONNECTED before sending POST_LOGIN.

  **Approach:** Add a `waitForState()` method is NOT needed because the existing `onMessage` callback already works only when connected. Instead, use a simpler approach: add an `onOpen` callback to WebSocketConnection (similar to the existing `onMessage` callback pattern).

  Modify `src/gateway/connection.ts` to add:
  ```typescript
  private onOpenCallback: (() => void) | null = null;

  /**
   * Register callback for connection open event
   */
  onOpen(callback: () => void): void {
    this.onOpenCallback = callback;
  }
  ```

  And in the existing `handleOpen()` method, after the current code, add:
  ```typescript
  if (this.onOpenCallback) {
    this.onOpenCallback();
  }
  ```

  **Wait -- this file is in Plan 01's files_modified (src/gateway/connection.ts). However, Plan 01 added markAuthenticated/isAuthenticated to it. Adding onOpen is a NEW concern.**

  Since this task already depends on Plan 01 (wave 2), and connection.ts was modified by Plan 01, this is fine -- we are building on top of Plan 01's changes.

  Add `onOpen` callback support to `src/gateway/connection.ts`:
  - Add `private onOpenCallback: (() => void) | null = null;` property
  - Add `onOpen(callback: () => void): void` public method (place near `onMessage()`)
  - In `handleOpen()`, call `this.onOpenCallback?.()` after existing logic

  Then update `src/main.ts`:

  ```typescript
  // Application entry point

  import { config } from './config';
  import { initLogger, logger } from './utils/logger';
  import { WebSocketConnection } from './gateway/connection';
  import { ConnectionConfig } from './types/connection';
  import { CommandClient } from './gateway/command-client';
  import { MessageRouter } from './gateway/message-router';
  import { NotificationHandler } from './gateway/notification-handler';
  import { authenticate } from './gateway/authenticator';
  import { discoverSensor } from './gateway/sensor-discovery';

  // Initialize logger with configured log level
  initLogger(config.LOG_LEVEL);

  logger.info('Gateway Integration Spike starting');

  // Log configuration summary (without password)
  logger.debug('Configuration:', {
    gatewayUrl: config.GATEWAY_URL,
    sensorSerial: config.SENSOR_SERIAL ?? '(auto-detect)',
    connectionTimeout: config.CONNECTION_TIMEOUT,
    commandTimeout: config.COMMAND_TIMEOUT,
    acquisitionTimeout: config.ACQUISITION_TIMEOUT,
    heartbeatInterval: config.HEARTBEAT_INTERVAL,
    logLevel: config.LOG_LEVEL,
  });

  // Build connection configuration
  const connectionConfig: ConnectionConfig = {
    url: config.GATEWAY_URL,
    reconnect: {
      initialDelay: 1000,
      maxDelay: 30000,
      multiplier: 2,
    },
    heartbeat: {
      interval: config.HEARTBEAT_INTERVAL,
      timeout: 5000,
    },
  };

  // Create WebSocket connection
  const connection = new WebSocketConnection(connectionConfig);

  // Create message infrastructure
  const commandClient = new CommandClient(
    (msg) => connection.send(msg),
    config.COMMAND_TIMEOUT
  );
  const notificationHandler = new NotificationHandler();
  const messageRouter = new MessageRouter(commandClient, notificationHandler);

  logger.info('Message infrastructure initialized');

  // Register message handler
  connection.onMessage((data) => messageRouter.handleMessage(data));

  // Graceful shutdown handling
  let isShuttingDown = false;

  function shutdown(signal: string): void {
    if (isShuttingDown) {
      logger.warn('Shutdown already in progress, forcing exit');
      process.exit(1);
    }
    isShuttingDown = true;
    logger.info(`Received ${signal} - starting graceful shutdown`);
    commandClient.cleanup();
    connection.close(1000, 'Application shutdown');
    setTimeout(() => {
      logger.warn('Graceful shutdown timeout - forcing exit');
      process.exit(1);
    }, 2000);
  }

  process.on('SIGINT', () => shutdown('SIGINT'));
  process.on('SIGTERM', () => shutdown('SIGTERM'));

  // ========================================================================
  // Application flow: connect -> authenticate -> discover
  // ========================================================================

  /**
   * Run the authentication and discovery flow after connection opens.
   * Called by onOpen callback.
   */
  async function onConnectionOpen(): Promise<void> {
    try {
      // AUTH-01, AUTH-02: Send POST_LOGIN with credentials
      await authenticate(commandClient, config);

      // AUTH-05: Transition to AUTHENTICATED state
      connection.markAuthenticated();

      // DISC-01, DISC-02, DISC-03, DISC-04: Discover and select sensor
      const sensor = await discoverSensor(commandClient, config.SENSOR_SERIAL);

      // Store selected sensor for Phase 5 acquisition
      logger.info(`Ready for data acquisition with sensor Serial=${sensor.Serial}`);
      logger.info('Phase 4 complete: authenticated and sensor discovered');

      // Phase 5 will add: subscribe to notifications, trigger reading, display data

    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);

      // DISC-05: No sensors connected - not an error, just nothing to do
      if (message.includes('No sensors currently connected')) {
        logger.warn('No sensors available - exiting gracefully');
        commandClient.cleanup();
        connection.close(1000, 'No sensors available');
        setTimeout(() => process.exit(0), 1000); // Exit 0 - valid state, nothing to do
        return;
      }

      // AUTH-04: Authentication failure or other error
      logger.error(`Startup failed: ${message}`);
      commandClient.cleanup();
      connection.close(1000, 'Startup failed');
      setTimeout(() => process.exit(1), 1000); // Exit 1 - actual failure
    }
  }

  // Register open handler and start connection
  connection.onOpen(() => {
    onConnectionOpen().catch((error) => {
      // Catch any unhandled errors from the async flow
      logger.error(`Unhandled error in connection flow: ${error}`);
      process.exit(1);
    });
  });

  logger.info(`Connecting to gateway at ${config.GATEWAY_URL}`);
  connection.connect();
  ```

  Key design decisions:
  - Uses `onOpen` callback pattern (consistent with existing `onMessage` pattern) rather than polling state or returning a Promise from connect().
  - The `onConnectionOpen()` async function contains the entire auth/discovery flow with try/catch.
  - Auth failure exits with code 1 (error). No sensors exits with code 0 (valid operational state per research).
  - Uses `setTimeout(() => process.exit(), 1000)` to allow connection.close() to complete before exiting.
  - Does NOT disable reconnection on auth failure -- connection.close(1000) uses code 1000 which is already non-reconnectable (decision from Phase 2).
  - Selected sensor is logged but not yet stored globally -- Phase 5 will need to add sensor storage for the acquisition flow.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no type errors. Check that main.ts imports authenticate and discoverSensor. Check that connection.ts has the onOpen method. Run `npx vitest run` if tests exist.
  </verify>
  <done>
  main.ts orchestrates full flow: connect -> onOpen -> authenticate -> markAuthenticated -> discoverSensor -> log ready. Auth failure exits code 1 with clear error. No sensors exits code 0 with warning. Connection.ts has onOpen callback. All requirements covered: AUTH-01 through AUTH-05, DISC-01 through DISC-05.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/gateway/sensor-discovery.ts` exists and exports `discoverSensor`
3. `src/main.ts` imports and calls `authenticate()` and `discoverSensor()`
4. `src/main.ts` calls `connection.markAuthenticated()` after successful auth
5. `src/gateway/connection.ts` has `onOpen()` callback method
6. Auth flow: POST_LOGIN sent with email/password, 10s timeout, clear error on failure
7. Discovery flow: GET_DYN_CONNECTED sent, dictionary parsed per-entry with safeParse, Connected filter applied
8. No sensors case: logs warning, exits with code 0
9. Auth failure case: logs error, exits with code 1
10. Existing tests still pass: `npx vitest run`
</verification>

<success_criteria>
- Complete application flow works: connect -> authenticate -> discover sensor -> ready for Phase 5
- All AUTH requirements met: POST_LOGIN sent after connection (AUTH-01), credentials from config (AUTH-02), waits for response (AUTH-03), failure handled with clear error (AUTH-04), AUTHENTICATED state transition only on success (AUTH-05)
- All DISC requirements met: GET_DYN_CONNECTED sent (DISC-01), RTN_DYN parsed (DISC-02), sensor fields extracted (DISC-03), first/preferred sensor selected (DISC-04), no sensors handled gracefully (DISC-05)
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-and-discovery/04-02-SUMMARY.md`
</output>
