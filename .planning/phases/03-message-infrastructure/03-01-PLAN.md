---
phase: 03-message-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/messages.ts
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "All CTC gateway message types have TypeScript interfaces with Zod runtime validation"
    - "Send command types (POST_LOGIN, POST_SUB_CHANGES, POST_UNSUB_CHANGES, GET_DYN_CONNECTED, TAKE_DYN_READING) are defined"
    - "Return response types (RTN_DYN, RTN_ERR) are defined with discriminated union"
    - "Notification types (NOT_DYN_READING_STARTED, NOT_DYN_READING, NOT_DYN_TEMP) are defined"
    - "SensorMetadata type captures all sensor fields from GET_DYN_CONNECTED response"
  artifacts:
    - path: "src/types/messages.ts"
      provides: "All Zod schemas and inferred TypeScript types for gateway messages"
      exports: ["SendCommandSchema", "ResponseMessageSchema", "NotificationMessageSchema", "GatewayMessageSchema", "SensorMetadataSchema"]
      contains: "z.discriminatedUnion"
    - path: "src/types/index.ts"
      provides: "Re-exports message types"
      contains: "messages"
  key_links:
    - from: "src/types/messages.ts"
      to: "zod"
      via: "import { z } from 'zod'"
      pattern: "import.*zod"
---

<objective>
Define all CTC gateway message types as Zod schemas with TypeScript type inference.

Purpose: Establish the type foundation for all message handling. Every gateway message (commands sent, responses received, notifications pushed) gets a Zod schema that provides both compile-time TypeScript types and runtime JSON validation. This is the foundation that Plan 02 (command client) and Plan 03 (message router) both depend on.

Output: `src/types/messages.ts` with Zod schemas and inferred types for all gateway message categories.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/connection.ts
@src/types/index.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod message schemas for all gateway message types</name>
  <files>src/types/messages.ts</files>
  <action>
Create `src/types/messages.ts` with Zod schemas covering all three message categories. Use `z.infer<>` to derive TypeScript types from schemas (single source of truth per research recommendation).

**Base message structure:**
All gateway messages share: Type (string), From (string). Commands use "To" field, responses/notifications use "Target" field.

**Send commands (TYPE-01) - 5 schemas:**
1. `PostLoginCommand`: Type="POST_LOGIN", From="UI", To="SERV", Data: { Email: string, Password: string }
2. `PostSubChangesCommand`: Type="POST_SUB_CHANGES", From="UI", To="SERV", Data: {} (empty object)
3. `PostUnsubChangesCommand`: Type="POST_UNSUB_CHANGES", From="UI", To="SERV", Data: {} (empty object)
4. `GetDynConnectedCommand`: Type="GET_DYN_CONNECTED", From="UI", To="SERV", Data: {} (empty object)
5. `TakeDynReadingCommand`: Type="TAKE_DYN_READING", From="UI", To="SERV", Data: { Serial: z.number() }

Each command schema should also include an optional CorrelationId field (string, UUID) that the command client will inject before sending. Define a `SendCommand` discriminated union of all 5 command schemas.

Also export a `CommandType` type that is the union of all command Type literals ("POST_LOGIN" | "POST_SUB_CHANGES" | etc.), and a `commandTypeToResponseType` mapping record that maps command types to their expected RTN_ response type (e.g., "GET_DYN_CONNECTED" -> "RTN_DYN", "POST_LOGIN" -> "RTN_DYN"). Default mapping for commands without specific response: any RTN_ type. This mapping helps the command client know which response type to expect.

**Return responses (TYPE-02) - 2 schemas:**
1. `ReturnDynResponse`: Type="RTN_DYN", From="SERV", Target="UI", CorrelationId: string (uuid), Data: z.record(z.unknown()) -- use permissive Data since RTN_DYN structure varies by command (login returns different data than GET_DYN_CONNECTED)
2. `ReturnErrorResponse`: Type="RTN_ERR", From="SERV", Target="UI", CorrelationId: string (uuid), Data: { Attempt: string, Error: string }

Note on RTN_ERR: The Attempt field from the CTC API documentation is a string describing what was attempted (e.g., "POST_LOGIN"), not a number. The Error field contains the error description.

Create a `ResponseMessage` discriminated union on "Type" field using z.discriminatedUnion().

**Notification messages (TYPE-03) - 3 schemas:**
1. `NotDynReadingStarted`: Type="NOT_DYN_READING_STARTED", From="SERV", Target="UI", Data: { Serial: z.number(), Success: z.boolean() }
2. `NotDynReading`: Type="NOT_DYN_READING", From="SERV", Target="UI", Data: { ID: z.number(), Serial: z.string(), Time: z.string(), X: z.string(), Y: z.string(), Z: z.string() } -- X/Y/Z are strings (encoding TBD, will be decoded in Phase 5)
3. `NotDynTemp`: Type="NOT_DYN_TEMP", From="SERV", Target="UI", Data: { Serial: z.string(), Temp: z.number() }

Create a `NotificationMessage` discriminated union on "Type" field.

**Sensor metadata (TYPE-04):**
Define `SensorMetadataSchema` for sensor objects returned in RTN_DYN response to GET_DYN_CONNECTED:
- Serial: z.number()
- PartNum: z.string()
- ReadRate: z.number()
- Samples: z.number()
- Name: z.string().optional()
- Use z.passthrough() on the schema to allow additional unknown fields from the gateway without breaking validation.

**Top-level union:**
Create a `GatewayMessage` discriminated union that combines ResponseMessage and NotificationMessage (for routing incoming messages). Do NOT include SendCommand in this union (those are outbound only).

**Export all schemas AND their inferred types:**
```typescript
export type PostLoginCommand = z.infer<typeof PostLoginCommandSchema>;
export type SendCommand = z.infer<typeof SendCommandSchema>;
export type ResponseMessage = z.infer<typeof ResponseMessageSchema>;
// etc.
```

**Important:** Use z.literal() for the Type field in every schema to enable discriminated union narrowing. Use the Zod 4.x API (the project has zod ^4.3.6 per research). Note: In Zod 4 the import is still `import { z } from 'zod'` and discriminatedUnion API is the same.

**Avoid:** Do NOT use TypeScript `as` assertions or manual interfaces -- derive everything from Zod schemas with z.infer<>. This ensures runtime validation and compile-time types stay in sync.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. All types should compile without errors. Verify the file exports at least: SendCommandSchema, ResponseMessageSchema, NotificationMessageSchema, GatewayMessageSchema, SensorMetadataSchema, and their inferred types.
  </verify>
  <done>
All 10 message schemas defined (5 commands, 2 responses, 3 notifications) plus SensorMetadata. Discriminated unions compile. Types are inferred from Zod schemas. File compiles with zero TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update types/index.ts to re-export message types</name>
  <files>src/types/index.ts</files>
  <action>
Update `src/types/index.ts` to re-export everything from the new messages module. Replace the placeholder comment `// Gateway API type definitions - populated in Phase 3` with a proper re-export.

The file should contain:
```typescript
// Connection management types
export * from './connection';

// Gateway message types (commands, responses, notifications)
export * from './messages';
```

Remove the placeholder `export {};` line.
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify that importing from `../types` or `../types/index` gives access to all message types (SendCommand, ResponseMessage, etc.).
  </verify>
  <done>
types/index.ts re-exports all message types alongside connection types. No TypeScript errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/types/messages.ts` exists and exports Zod schemas for all 10 message types
3. `src/types/index.ts` re-exports both connection and message types
4. Discriminated unions work: ResponseMessageSchema can distinguish RTN_DYN from RTN_ERR
5. GatewayMessageSchema can distinguish all incoming message types (RTN_ and NOT_)
</verification>

<success_criteria>
- TYPE-01: All 5 Send command interfaces defined with Zod schemas
- TYPE-02: Both Return response interfaces defined with discriminated union
- TYPE-03: All 3 Notification interfaces defined with discriminated union
- TYPE-04: SensorMetadata type defined with all documented fields
- All types compile, all schemas export both Zod schema and inferred TypeScript type
</success_criteria>

<output>
After completion, create `.planning/phases/03-message-infrastructure/03-01-SUMMARY.md`
</output>
