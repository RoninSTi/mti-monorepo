---
phase: 03-message-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/gateway/message-router.ts
  - src/gateway/notification-handler.ts
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "Incoming WebSocket messages are parsed as JSON and validated with Zod"
    - "RTN_ messages are routed to CommandClient.handleResponse for correlation"
    - "NOT_ messages are routed to NotificationHandler for async processing"
    - "Invalid/unknown messages are logged as warnings without crashing"
    - "Application wires message router into WebSocketConnection.onMessage callback"
    - "CommandClient is created with connection.send as the sendFn"
  artifacts:
    - path: "src/gateway/message-router.ts"
      provides: "MessageRouter class that routes parsed messages by Type prefix"
      exports: ["MessageRouter"]
      min_lines: 40
    - path: "src/gateway/notification-handler.ts"
      provides: "NotificationHandler class that accepts NOT_ message callbacks"
      exports: ["NotificationHandler"]
      min_lines: 25
    - path: "src/main.ts"
      provides: "Updated entry point wiring MessageRouter, CommandClient, NotificationHandler into connection"
      contains: "MessageRouter"
  key_links:
    - from: "src/gateway/message-router.ts"
      to: "src/gateway/command-client.ts"
      via: "Calls commandClient.handleResponse for RTN_ messages"
      pattern: "handleResponse"
    - from: "src/gateway/message-router.ts"
      to: "src/gateway/notification-handler.ts"
      via: "Calls notificationHandler.handle for NOT_ messages"
      pattern: "notificationHandler"
    - from: "src/gateway/message-router.ts"
      to: "src/types/messages.ts"
      via: "Uses ResponseMessageSchema and NotificationMessageSchema for Zod validation"
      pattern: "safeParse"
    - from: "src/main.ts"
      to: "src/gateway/message-router.ts"
      via: "Registers router.handleMessage as connection.onMessage callback"
      pattern: "onMessage.*router"
---

<objective>
Implement message routing and notification handling, then wire the complete message infrastructure into the application.

Purpose: Connect the type system (Plan 01) and command client (Plan 02) into a working message pipeline. Incoming WebSocket messages get parsed, validated with Zod, and routed to either the CommandClient (for RTN_ responses) or NotificationHandler (for NOT_ async events). The application entry point is updated to create and wire all components.

Output: Working message pipeline: WebSocket -> MessageRouter -> CommandClient/NotificationHandler, integrated in main.ts.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-message-infrastructure/03-01-SUMMARY.md
@.planning/phases/03-message-infrastructure/03-02-SUMMARY.md
@src/types/messages.ts
@src/gateway/command-client.ts
@src/gateway/connection.ts
@src/main.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MessageRouter and NotificationHandler</name>
  <files>src/gateway/message-router.ts, src/gateway/notification-handler.ts</files>
  <action>
**NotificationHandler (`src/gateway/notification-handler.ts`):**

Create a NotificationHandler class that manages callbacks for notification message types.

```
class NotificationHandler {
  private handlers: Map<string, (data: unknown) => void>

  on(type: string, callback: (data: unknown) => void): void
    - Register a handler for a specific notification Type (e.g., "NOT_DYN_READING")

  handle(message: NotificationMessage): void
    - Look up handler by message.Type
    - If handler exists, call it with message.Data
    - If no handler registered, log debug: "No handler for notification: {Type}"
    - Log at debug level: "Notification received: {Type}"
}
```

This is intentionally simple -- Phase 5 will register the actual NOT_DYN_READING handlers. For now it's a callback registry.

**MessageRouter (`src/gateway/message-router.ts`):**

Create a MessageRouter class that parses raw WebSocket messages and routes them to the appropriate handler.

```
class MessageRouter {
  constructor(
    private commandClient: CommandClient,
    private notificationHandler: NotificationHandler
  )

  handleMessage(raw: string): void
    1. Try JSON.parse(raw). If fails, log warn "Received non-JSON message" and return.
    2. Check if parsed object has a "Type" field (string). If not, log warn "Message missing Type field" and return.
    3. Determine message category by Type prefix:
       - Type starts with "RTN_": This is a command response
         a. Validate with ResponseMessageSchema.safeParse()
         b. If valid, call this.commandClient.handleResponse(validated)
         c. If invalid, log warn with Zod error issues
       - Type starts with "NOT_": This is a notification
         a. Validate with NotificationMessageSchema.safeParse()
         b. If valid, call this.notificationHandler.handle(validated)
         c. If invalid, log warn with Zod error issues
       - Otherwise: log warn "Unknown message type: {Type}"
    4. Log every incoming message at debug level (the raw string, truncated to 200 chars) -- this satisfies CMD-06 for received messages.
```

**Important design notes:**
- Use Zod safeParse (not parse) to avoid throwing on invalid messages -- the gateway is untrusted.
- The router does NOT import ws or WebSocketConnection -- it receives a raw string, keeping it decoupled.
- Import types from `../types/messages` (ResponseMessageSchema, NotificationMessageSchema, etc.)
- Import CommandClient type and NotificationHandler type for constructor.
- Import logger from `../utils/logger`.
  </action>
  <verify>
Run `npx tsc --noEmit`. Both files compile. MessageRouter correctly imports CommandClient and NotificationHandler. Zod schemas are used for validation.
  </verify>
  <done>
MessageRouter parses JSON, validates with Zod, routes RTN_ to CommandClient and NOT_ to NotificationHandler. NotificationHandler provides callback registration for notification types. Both compile with zero TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire message infrastructure into main.ts</name>
  <files>src/main.ts</files>
  <action>
Update `src/main.ts` to create and wire all message infrastructure components. The existing connection setup and shutdown logic remain -- add the message layer on top.

**Changes to main.ts:**

1. Add imports:
   ```typescript
   import { CommandClient } from './gateway/command-client';
   import { MessageRouter } from './gateway/message-router';
   import { NotificationHandler } from './gateway/notification-handler';
   ```

2. After creating the WebSocketConnection, create the message infrastructure:
   ```typescript
   // Create message infrastructure
   const commandClient = new CommandClient(
     (msg) => connection.send(msg),
     config.COMMAND_TIMEOUT
   );
   const notificationHandler = new NotificationHandler();
   const messageRouter = new MessageRouter(commandClient, notificationHandler);
   ```

3. Replace the existing placeholder onMessage handler:
   ```typescript
   // OLD (remove):
   connection.onMessage((data) => {
     logger.debug('Message received (unhandled):', data.substring(0, 200));
   });

   // NEW:
   connection.onMessage((data) => messageRouter.handleMessage(data));
   ```

4. Update the shutdown function to also clean up the command client:
   ```typescript
   function shutdown(signal: string): void {
     if (isShuttingDown) {
       logger.warn('Shutdown already in progress, forcing exit');
       process.exit(1);
     }
     isShuttingDown = true;
     logger.info(`Received ${signal} - starting graceful shutdown`);

     // Clean up message infrastructure first
     commandClient.cleanup();

     connection.close(1000, 'Application shutdown');

     setTimeout(() => {
       logger.warn('Graceful shutdown timeout - forcing exit');
       process.exit(1);
     }, 2000);
   }
   ```

5. Log that message infrastructure is ready:
   ```typescript
   logger.info('Message infrastructure initialized (router, command client, notification handler)');
   ```

**Keep everything else unchanged** -- connection config, signal handlers, the connect() call at the end. The commandClient, notificationHandler, and messageRouter are available in module scope for Phase 4 to use for authentication and sensor discovery.

**Export or make accessible for Phase 4:**
Since main.ts is the entry point (not a module imported elsewhere), Phase 4 will either:
- Add authentication logic directly in main.ts using these objects, OR
- Extract them to a setup module

For now, keep them as module-level constants in main.ts. Phase 4 planning will decide the approach.
  </action>
  <verify>
Run `npx tsc --noEmit`. main.ts compiles with all new imports and wiring. Run `node --env-file=.env dist/main.js` briefly (it will try to connect to gateway -- just verify it starts without import/type errors, then Ctrl+C). Check logs show "Message infrastructure initialized".
  </verify>
  <done>
main.ts creates CommandClient, NotificationHandler, and MessageRouter. MessageRouter is wired into connection.onMessage. CommandClient cleanup is called during shutdown. Application compiles and starts without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across all files
2. `src/gateway/message-router.ts` uses Zod safeParse for incoming message validation
3. `src/gateway/notification-handler.ts` provides callback registration for NOT_ types
4. `src/main.ts` wires MessageRouter -> connection.onMessage
5. `src/main.ts` creates CommandClient with connection.send callback and config.COMMAND_TIMEOUT
6. Shutdown path cleans up CommandClient pending requests
7. Full message flow: WebSocket message -> MessageRouter.handleMessage -> JSON parse -> Zod validate -> CommandClient.handleResponse (RTN_) or NotificationHandler.handle (NOT_)
</verification>

<success_criteria>
- CMD-02: RTN_ response messages are received, parsed, and routed to CommandClient
- CMD-06: All received messages logged at debug level (in MessageRouter)
- Complete message pipeline wired: connection -> router -> command client / notification handler
- Application compiles and starts without errors
- Graceful shutdown includes CommandClient cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/03-message-infrastructure/03-03-SUMMARY.md`
</output>
