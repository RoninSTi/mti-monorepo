---
phase: 03-message-infrastructure
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/gateway/command-client.ts
  - src/gateway/command-client.test.ts
autonomous: true

must_haves:
  truths:
    - "Commands are sent as JSON with Type/From/To/Data/CorrelationId structure"
    - "Responses are matched to commands via correlation ID"
    - "Commands timeout after configurable duration (default 30s) with clear error"
    - "RTN_ERR responses reject the command promise with Attempt and Error fields"
    - "Sent commands and received responses are logged"
    - "Timed-out pending requests are cleaned up (no memory leak)"
  artifacts:
    - path: "src/gateway/command-client.ts"
      provides: "CommandClient class with sendCommand, handleResponse, cleanup"
      exports: ["CommandClient"]
      min_lines: 80
    - path: "src/gateway/command-client.test.ts"
      provides: "Tests for command correlation, timeout, error handling"
      contains: "describe.*CommandClient"
  key_links:
    - from: "src/gateway/command-client.ts"
      to: "src/types/messages.ts"
      via: "imports SendCommand, ResponseMessage types"
      pattern: "import.*messages"
    - from: "src/gateway/command-client.ts"
      to: "crypto"
      via: "randomUUID for correlation IDs"
      pattern: "randomUUID"
---

<objective>
Implement the CommandClient class that sends commands over WebSocket and correlates responses using UUID-based correlation IDs, with configurable timeout and RTN_ERR rejection.

Purpose: This is the core command/response engine. It turns the bidirectional WebSocket into a request/response pattern by correlating outgoing commands with incoming responses via CorrelationId. This is a TDD plan because the correlation, timeout, and error handling logic has clearly defined inputs and outputs that benefit from test-first design.

Output: Working `CommandClient` class with tests proving correlation, timeout, and error behavior.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-message-infrastructure/03-01-SUMMARY.md
@src/types/messages.ts
@src/gateway/connection.ts
@src/config.ts
</context>

<feature>
  <name>CommandClient: Command/Response correlation with timeout</name>
  <files>src/gateway/command-client.ts, src/gateway/command-client.test.ts</files>
  <behavior>
    CommandClient wraps a send function (callback-based, same pattern as HeartbeatManager) and provides Promise-based command sending with automatic correlation.

    **Constructor:** Takes a `sendFn: (message: string) => boolean` callback and optional `defaultTimeoutMs: number` (default 30000).

    **sendCommand(command, timeoutMs?):**
    - Generates UUID correlation ID via crypto.randomUUID()
    - Injects CorrelationId into command object
    - Serializes to JSON and calls sendFn
    - Returns Promise that resolves with response Data or rejects on timeout/error
    - If sendFn returns false (connection not open), reject immediately with "Connection not available" error
    - Logs sent command at debug level: command Type and CorrelationId

    **handleResponse(message: ResponseMessage):**
    - Looks up CorrelationId in pending requests Map
    - If not found, log warning and return (stale/timed-out response)
    - If found, clear timeout, delete from Map
    - If message.Type === "RTN_ERR": reject with Error containing Attempt and Error fields
    - If message.Type === "RTN_DYN" (or any non-error): resolve with message.Data
    - Log response at debug level: response Type, CorrelationId, and whether it was RTN_ERR

    **cleanup():**
    - Reject all pending requests with "CommandClient shutting down" error
    - Clear all timeouts
    - Clear the pending Map

    **getPendingCount():**
    - Returns number of pending requests (for debugging/monitoring)

    Cases:
    - sendCommand(loginCmd) + handleResponse(rtnDyn with matching ID) -> resolves with Data
    - sendCommand(loginCmd) + handleResponse(rtnErr with matching ID) -> rejects with error containing Attempt and Error
    - sendCommand(loginCmd) + no response within timeout -> rejects with timeout error
    - sendCommand(cmd) when sendFn returns false -> rejects immediately
    - handleResponse with unknown CorrelationId -> logs warning, no crash
    - cleanup() with pending requests -> all reject with shutdown error
    - Race: timeout fires then response arrives -> response handler finds nothing in Map, logs warning (safe)
  </behavior>
  <implementation>
    Use the "delete first, then act" pattern from research to handle the race condition between timeout and response. Whoever successfully deletes the pending entry from the Map wins.

    Use native crypto.randomUUID() for correlation IDs (per research, no uuid package).
    Use setTimeout for timeouts (simpler than AbortSignal for this use case, per research Pattern 1 example).

    Store pending requests as: Map<string, { resolve, reject, timeoutId, commandType, sentAt }>

    The sendFn callback decouples CommandClient from WebSocketConnection (same composition pattern as HeartbeatManager from Phase 2).

    For tests: Use vitest (check if already in project, otherwise use Node.js built-in test runner). Mock the sendFn callback. Test cases:
    1. RED: sendCommand resolves when handleResponse called with matching CorrelationId
    2. RED: sendCommand rejects with timeout error when no response arrives
    3. RED: sendCommand rejects with RTN_ERR details when error response received
    4. RED: sendCommand rejects immediately when sendFn returns false
    5. RED: handleResponse with unknown ID logs warning and doesn't throw
    6. RED: cleanup rejects all pending requests

    Use fake timers (jest.useFakeTimers or equivalent) for timeout tests to avoid real delays.
  </implementation>
</feature>

<verification>
1. All tests pass: `npx tsx --test src/gateway/command-client.test.ts` (or vitest/jest depending on test runner)
2. `npx tsc --noEmit` passes
3. CommandClient class exports correctly from src/gateway/command-client.ts
4. Pending request Map is properly cleaned up in all paths (timeout, response, error, shutdown)
</verification>

<success_criteria>
- CMD-01: sendCommand serializes commands as JSON with Type/From/To/Data/CorrelationId
- CMD-03: Responses matched via CorrelationId (UUID-based)
- CMD-04: Configurable timeout (default 30s) rejects with clear error message
- CMD-05: RTN_ERR responses parsed and rejected with Attempt and Error fields
- CMD-06: Sent commands and received responses logged at debug level
- All tests pass, no memory leaks in pending request cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/03-message-infrastructure/03-02-SUMMARY.md`
</output>
