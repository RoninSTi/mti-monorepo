---
phase: 12-frontend-foundation
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - frontend/src/lib/query-client.ts
  - frontend/src/lib/api.ts
  - frontend/src/types/api.ts
  - frontend/src/main.tsx
  - frontend/vite.config.ts
  - frontend/.env
autonomous: true

must_haves:
  truths:
    - "React Query DevTools icon appears in browser when running dev server"
    - "API client can fetch from backend via Vite proxy (localhost:5173/api proxies to localhost:3000/api)"
    - "TypeScript interfaces for Factory and Gateway match backend response schemas exactly"
    - "React Hook Form is installed and importable"
  artifacts:
    - path: "frontend/src/lib/query-client.ts"
      provides: "React Query client with default options"
      exports: ["queryClient"]
    - path: "frontend/src/lib/api.ts"
      provides: "Typed API client with GET, POST, PUT, DELETE methods"
      exports: ["api"]
    - path: "frontend/src/types/api.ts"
      provides: "TypeScript interfaces matching backend API schemas"
      contains: "Factory"
    - path: "frontend/src/main.tsx"
      provides: "App entry point wrapped with QueryClientProvider"
      contains: "QueryClientProvider"
    - path: "frontend/vite.config.ts"
      provides: "Dev server proxy from /api to localhost:3000"
      contains: "proxy"
  key_links:
    - from: "frontend/src/main.tsx"
      to: "frontend/src/lib/query-client.ts"
      via: "QueryClientProvider wraps App"
      pattern: "QueryClientProvider.*client.*queryClient"
    - from: "frontend/src/lib/api.ts"
      to: "frontend/vite.config.ts"
      via: "API client uses /api prefix, proxy forwards to backend"
      pattern: "/api"
    - from: "frontend/src/types/api.ts"
      to: "src/api/schemas/factories.ts"
      via: "Frontend types mirror backend Zod schemas (manually maintained)"
      pattern: "interface Factory"
---

<objective>
Configure React Query provider with DevTools, create a typed API client with Vite proxy to the Fastify backend, define TypeScript interfaces matching backend schemas, and install React Hook Form.

Purpose: Establishes the data fetching infrastructure and API integration layer that Phase 14 (API Integration Layer) will build hooks on top of.
Output: QueryClientProvider wrapping the app, API client ready for use, TypeScript types for Factory/Gateway matching backend, React Hook Form available.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-frontend-foundation/12-RESEARCH.md
@.planning/phases/12-frontend-foundation/12-01-SUMMARY.md

# Backend API schemas (frontend types must match these)
@src/api/schemas/factories.ts
@src/api/schemas/gateways.ts
@src/api/schemas/common.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install React Query, React Hook Form, and configure providers</name>
  <files>
    frontend/src/lib/query-client.ts
    frontend/src/main.tsx
    frontend/package.json
  </files>
  <action>
    1. From the frontend directory, install React Query and DevTools:
       ```bash
       cd frontend
       npm install @tanstack/react-query @tanstack/react-query-devtools
       ```

    2. Install React Hook Form:
       ```bash
       npm install react-hook-form
       ```

    3. Create `src/lib/query-client.ts` with sensible defaults:
       ```typescript
       import { QueryClient } from '@tanstack/react-query'

       export const queryClient = new QueryClient({
         defaultOptions: {
           queries: {
             staleTime: 5 * 60 * 1000, // 5 minutes - avoids excessive refetching
             retry: 1,                  // Single retry on failure
             refetchOnWindowFocus: false, // Don't refetch when tab regains focus
           },
         },
       })
       ```

    4. Update `src/main.tsx` to wrap the app with QueryClientProvider and add DevTools:
       ```tsx
       import React from 'react'
       import ReactDOM from 'react-dom/client'
       import { QueryClientProvider } from '@tanstack/react-query'
       import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
       import { queryClient } from '@/lib/query-client'
       import App from './App'
       import './index.css'

       ReactDOM.createRoot(document.getElementById('root')!).render(
         <React.StrictMode>
           <QueryClientProvider client={queryClient}>
             <App />
             <ReactQueryDevtools initialIsOpen={false} />
           </QueryClientProvider>
         </React.StrictMode>,
       )
       ```
  </action>
  <verify>
    ```bash
    cd frontend && npm run build
    grep -q "@tanstack/react-query" frontend/package.json && echo "PASS: React Query installed"
    grep -q "react-hook-form" frontend/package.json && echo "PASS: React Hook Form installed"
    grep -q "QueryClientProvider" frontend/src/main.tsx && echo "PASS: Provider in main.tsx"
    grep -q "ReactQueryDevtools" frontend/src/main.tsx && echo "PASS: DevTools in main.tsx"
    ```
  </verify>
  <done>
    - React Query v5 and DevTools installed
    - React Hook Form installed
    - QueryClient configured with 5-minute staleTime and single retry
    - main.tsx wraps App with QueryClientProvider
    - ReactQueryDevtools included (auto-removed in production builds)
    - Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API client, TypeScript types, and Vite proxy config</name>
  <files>
    frontend/src/lib/api.ts
    frontend/src/types/api.ts
    frontend/vite.config.ts
    frontend/.env
  </files>
  <action>
    1. Create `src/types/api.ts` with TypeScript interfaces matching the backend Zod schemas EXACTLY. Reference `src/api/schemas/factories.ts`, `src/api/schemas/gateways.ts`, and `src/api/schemas/common.ts` in the backend:

       ```typescript
       /**
        * Frontend TypeScript types matching backend API schemas.
        *
        * These are manually maintained to match the Zod schemas in:
        * - src/api/schemas/factories.ts
        * - src/api/schemas/gateways.ts
        * - src/api/schemas/common.ts
        *
        * If backend schemas change, update these types to match.
        */

       // Pagination (matches paginationResponseSchema)
       export interface Pagination {
         total: number
         limit: number
         offset: number
         hasNext: boolean
         hasPrev: boolean
       }

       export interface PaginatedResponse<T> {
         data: T[]
         pagination: Pagination
       }

       // Factory (matches factoryResponseSchema)
       export interface Factory {
         id: string
         organization_id: string
         name: string
         location: string | null
         timezone: string
         metadata: Record<string, unknown>
         created_at: string
         updated_at: string
       }

       // Factory create input (matches createFactorySchema)
       export interface CreateFactoryInput {
         organization_id: string
         name: string
         location?: string | null
         timezone?: string
         metadata?: Record<string, unknown>
       }

       // Factory update input (matches updateFactorySchema)
       export interface UpdateFactoryInput {
         name?: string
         location?: string | null
         timezone?: string
         metadata?: Record<string, unknown>
       }

       // Gateway (matches gatewayResponseSchema - NO password fields per GATEWAY-07)
       export interface Gateway {
         id: string
         factory_id: string
         gateway_id: string
         name: string
         url: string
         email: string
         model: string | null
         firmware_version: string | null
         last_seen_at: string | null
         metadata: Record<string, unknown>
         created_at: string
         updated_at: string
       }

       // Gateway create input (matches createGatewaySchema)
       export interface CreateGatewayInput {
         factory_id: string
         gateway_id: string
         name: string
         url: string
         email: string
         password: string
         model?: string
         firmware_version?: string
         metadata?: Record<string, unknown>
       }

       // Gateway update input (matches updateGatewaySchema)
       export interface UpdateGatewayInput {
         gateway_id?: string
         name?: string
         url?: string
         email?: string
         password?: string
         model?: string
         firmware_version?: string
         metadata?: Record<string, unknown>
       }

       // API error response
       export interface ApiError {
         statusCode: number
         error: string
         message: string
       }
       ```

    2. Create `src/lib/api.ts` with a typed API client:
       ```typescript
       import type { ApiError } from '@/types/api'

       const API_BASE = '/api'

       class ApiClient {
         private async request<T>(endpoint: string, options?: RequestInit): Promise<T> {
           const url = `${API_BASE}${endpoint}`
           const response = await fetch(url, {
             headers: {
               'Content-Type': 'application/json',
               ...options?.headers,
             },
             ...options,
           })

           if (!response.ok) {
             let error: ApiError
             try {
               error = await response.json()
             } catch {
               error = {
                 statusCode: response.status,
                 error: response.statusText,
                 message: `Request failed: ${response.statusText}`,
               }
             }
             throw error
           }

           // Handle 204 No Content (e.g., DELETE responses)
           if (response.status === 204) {
             return undefined as T
           }

           return response.json()
         }

         async get<T>(endpoint: string): Promise<T> {
           return this.request<T>(endpoint)
         }

         async post<T>(endpoint: string, data: unknown): Promise<T> {
           return this.request<T>(endpoint, {
             method: 'POST',
             body: JSON.stringify(data),
           })
         }

         async put<T>(endpoint: string, data: unknown): Promise<T> {
           return this.request<T>(endpoint, {
             method: 'PUT',
             body: JSON.stringify(data),
           })
         }

         async patch<T>(endpoint: string, data: unknown): Promise<T> {
           return this.request<T>(endpoint, {
             method: 'PATCH',
             body: JSON.stringify(data),
           })
         }

         async delete<T>(endpoint: string): Promise<T> {
           return this.request<T>(endpoint, {
             method: 'DELETE',
           })
         }
       }

       export const api = new ApiClient()
       ```

    3. Update `frontend/vite.config.ts` to add the API proxy (merge with existing config from Plan 01):
       ```typescript
       import { defineConfig } from 'vite'
       import react from '@vitejs/plugin-react'
       import tailwindcss from '@tailwindcss/vite'
       import path from 'path'

       export default defineConfig({
         plugins: [react(), tailwindcss()],
         resolve: {
           alias: {
             '@': path.resolve(__dirname, './src'),
           },
         },
         server: {
           proxy: {
             '/api': {
               target: 'http://localhost:3000',
               changeOrigin: true,
               // No rewrite needed - backend expects /api prefix
             },
           },
         },
       })
       ```

    4. Create `frontend/.env` with a comment documenting the proxy setup:
       ```
       # API configuration
       # In development, Vite proxy forwards /api requests to the backend.
       # In production, set VITE_API_URL to the backend URL.
       # VITE_API_URL=http://localhost:3000/api
       ```

    5. Verify build succeeds:
       ```bash
       cd frontend && npm run build
       ```
  </action>
  <verify>
    ```bash
    cd frontend && npm run build
    grep -q "interface Factory" frontend/src/types/api.ts && echo "PASS: Factory type defined"
    grep -q "interface Gateway" frontend/src/types/api.ts && echo "PASS: Gateway type defined"
    grep -q "class ApiClient" frontend/src/lib/api.ts && echo "PASS: API client created"
    grep -q "proxy" frontend/vite.config.ts && echo "PASS: Proxy configured"
    grep -q "localhost:3000" frontend/vite.config.ts && echo "PASS: Proxy targets backend"
    ```
  </verify>
  <done>
    - src/types/api.ts defines Factory, Gateway, Pagination, and input types matching backend schemas
    - src/lib/api.ts exports typed ApiClient with get/post/put/patch/delete methods
    - API client uses /api base path (proxied in dev, configurable for production)
    - vite.config.ts proxies /api requests to localhost:3000 with changeOrigin: true
    - .env documents API configuration
    - Gateway types exclude password fields (matching GATEWAY-07 security requirement)
    - Build succeeds with zero TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npm run build` exits with code 0
2. `grep "@tanstack/react-query" frontend/package.json` returns a match
3. `grep "react-hook-form" frontend/package.json` returns a match
4. `grep "QueryClientProvider" frontend/src/main.tsx` returns a match
5. `grep "interface Factory" frontend/src/types/api.ts` returns a match
6. `grep "interface Gateway" frontend/src/types/api.ts` returns a match
7. `grep "proxy" frontend/vite.config.ts` returns a match
8. `grep "class ApiClient" frontend/src/lib/api.ts` returns a match
</verification>

<success_criteria>
- SETUP-04 satisfied: React Query configured for API state management (provider + DevTools)
- SETUP-05 satisfied: React Hook Form installed for form handling (importable)
- SETUP-06 satisfied: API client configured to connect to Fastify backend (proxy + typed client)
- React Query DevTools available in development
- TypeScript types match backend Zod schemas for Factory and Gateway
- API client handles errors, 204 responses, and all HTTP methods
- Vite proxy forwards /api to localhost:3000
</success_criteria>

<output>
After completion, create `.planning/phases/12-frontend-foundation/12-03-SUMMARY.md`
</output>
