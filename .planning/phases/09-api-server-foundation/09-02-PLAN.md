---
phase: 09-api-server-foundation
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/api/routes/health.ts
  - src/api/server.ts
  - src/api/app.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Fastify server starts on configured port (default 3000) and responds to requests"
    - "GET /api/health returns 200 OK with status, timestamp, uptime, and version"
    - "Server shuts down gracefully on SIGINT/SIGTERM closing database connections"
    - "npm run dev:api starts the API server with hot reload"
  artifacts:
    - path: "src/api/routes/health.ts"
      provides: "Health check endpoint"
      exports: ["default"]
    - path: "src/api/server.ts"
      provides: "Server startup and shutdown"
      exports: ["startServer"]
  key_links:
    - from: "src/api/app.ts"
      to: "src/api/routes/health.ts"
      via: "fastify.register() with /api prefix"
      pattern: "register.*health.*prefix.*api"
    - from: "src/api/server.ts"
      to: "src/api/app.ts"
      via: "buildApp() import"
      pattern: "import.*buildApp.*from.*app"
    - from: "src/api/server.ts"
      to: "src/database/kysely.ts"
      via: "closeDatabase() on shutdown"
      pattern: "closeDatabase"
---

<objective>
Create the health check endpoint and server entry point that starts Fastify, registers routes, and handles graceful shutdown including database connection cleanup.

Purpose: Make the API server runnable end-to-end. After this plan, `npm run dev:api` starts a server that responds to `GET /api/health` with status information.
Output: Working API server with health check endpoint, npm scripts, and graceful shutdown.
</objective>

<execution_context>
@/Users/craigcronin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/craigcronin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-api-server-foundation/09-RESEARCH.md
@.planning/phases/09-api-server-foundation/09-01-SUMMARY.md

# Files from Plan 01
@src/api/app.ts
@src/api/config.ts
@src/api/plugins/error-handler.ts

# Existing infrastructure
@src/database/kysely.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health check route and register in app factory</name>
  <files>
    src/api/routes/health.ts
    src/api/app.ts
  </files>
  <action>
    Create `src/api/routes/health.ts`:
    - Import `FastifyPluginAsyncZod` from 'fastify-type-provider-zod' for full type inference
    - Import `z` from 'zod'
    - Define response schema with Zod:
      ```typescript
      const healthResponseSchema = z.object({
        status: z.literal('ok'),
        timestamp: z.string(),
        uptime: z.number(),
        version: z.string(),
      });
      ```
    - Export default as `FastifyPluginAsyncZod` plugin
    - Register `GET /health` route with:
      - Schema: `{ response: { 200: healthResponseSchema } }`
      - Handler returns `{ status: 'ok', timestamp: new Date().toISOString(), uptime: process.uptime(), version: '1.0.0' }`
    - Note: The route is `/health` not `/api/health` because the prefix `/api` is applied during registration in app.ts

    Update `src/api/app.ts`:
    - Add route registration AFTER all plugin registrations:
      ```typescript
      await app.register(import('./routes/health'), { prefix: '/api' });
      ```
    - This makes the health route available at `GET /api/health`
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `src/api/routes/health.ts` exists with GET /health route
    - `src/api/app.ts` registers health routes with `/api` prefix
  </verify>
  <done>
    Health check endpoint registered at GET /api/health. Returns status, timestamp, uptime, and version. Response validated against Zod schema for type safety.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create server entry point with graceful shutdown and npm scripts</name>
  <files>
    src/api/server.ts
    package.json
  </files>
  <action>
    Create `src/api/server.ts`:
    - Import `buildApp` from './app'
    - Import `apiConfig` from './config'
    - Import `closeDatabase` from '../database/kysely'
    - Export `async function startServer()`:
      1. Call `const app = await buildApp()`
      2. Try `await app.listen({ port: apiConfig.API_PORT, host: '0.0.0.0' })`
      3. Log: `app.log.info(\`Server listening on port ${apiConfig.API_PORT}\`)`
      4. On catch: `app.log.error(err)` then `process.exit(1)`
    - Register graceful shutdown for SIGINT and SIGTERM:
      ```typescript
      const shutdown = async (signal: string) => {
        app.log.info(`${signal} received, shutting down`);
        await app.close();     // Completes in-flight requests
        await closeDatabase();  // Close Kysely connection pool
        process.exit(0);
      };
      process.on('SIGINT', () => shutdown('SIGINT'));
      process.on('SIGTERM', () => shutdown('SIGTERM'));
      ```
    - At bottom of file, call `startServer()` so the file is directly executable

    Update `package.json` scripts:
    - Add `"dev:api": "tsx --env-file=.env src/api/server.ts"` — starts API server with hot reload
    - Add `"start:api": "node dist/api/server.js"` — starts compiled API server
    - Keep existing `"dev"` script (it runs the gateway spike) — they are separate entry points

    IMPORTANT: Do NOT modify `src/main.ts`. The API server has its own entry point (`src/api/server.ts`). The gateway spike (`src/main.ts`) remains separate and will be integrated in a future milestone.
  </action>
  <verify>
    Run the server and test:
    ```bash
    # Start server in background
    npm run dev:api &
    SERVER_PID=$!
    sleep 2

    # Test health endpoint
    curl -s http://localhost:3000/api/health | jq .

    # Test CORS headers
    curl -s -I -H "Origin: http://example.com" http://localhost:3000/api/health | grep -i "access-control"

    # Test security headers (Helmet)
    curl -s -I http://localhost:3000/api/health | grep -i "x-content-type-options\|x-frame-options"

    # Test 404 standardized error
    curl -s http://localhost:3000/api/nonexistent | jq .

    # Stop server
    kill $SERVER_PID
    ```

    Expected results:
    - Health returns `{ "status": "ok", "timestamp": "...", "uptime": N, "version": "1.0.0" }`
    - CORS: `access-control-allow-origin` header present
    - Helmet: `x-content-type-options: nosniff` and other security headers present
    - 404: `{ "error": { "code": "NOT_FOUND", "message": "...", "statusCode": 404 } }`
    - `npx tsc --noEmit` compiles without errors
  </verify>
  <done>
    API server starts on configured port (default 3000). Health check responds at GET /api/health with 200 OK. CORS and Helmet headers present on all responses. 404s return standardized error format. Graceful shutdown closes Fastify and database connections. `npm run dev:api` starts the server for development.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev:api` starts server on port 3000 (or configured API_PORT)
2. `curl http://localhost:3000/api/health` returns 200 with `{ status: 'ok', timestamp, uptime, version }`
3. CORS headers present: `access-control-allow-origin` on responses
4. Security headers present: `x-content-type-options`, `x-frame-options`, etc.
5. `curl http://localhost:3000/api/nonexistent` returns 404 in standardized error format
6. SIGINT/SIGTERM trigger graceful shutdown (closes server + database pool)
7. `npx tsc --noEmit` compiles with zero errors
</verification>

<success_criteria>
- Server starts and responds to HTTP requests
- GET /api/health returns 200 OK with status information
- CORS, Helmet, and error handling work end-to-end
- Graceful shutdown cleans up all resources
- npm scripts exist for dev and production
- All Phase 9 success criteria from ROADMAP.md are met
</success_criteria>

<output>
After completion, create `.planning/phases/09-api-server-foundation/09-02-SUMMARY.md`
</output>
